/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.2.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import org.openapitools.model.ConfigurationFilterRequest;
import org.openapitools.model.CreateTenantBody;
import org.openapitools.model.CronJob;
import org.openapitools.model.DataResponseBoolean;
import org.openapitools.model.DataResponseConfiguration;
import org.openapitools.model.DataResponseCronJob;
import org.openapitools.model.DataResponseDeletableResource;
import org.openapitools.model.DataResponseFlowInstance;
import org.openapitools.model.DataResponseFlowInstancesAndAssociatedJobs;
import org.openapitools.model.DataResponseFlowModelContextSnapshot;
import org.openapitools.model.DataResponseFlowModelSnapshot;
import org.openapitools.model.DataResponseFlowStep;
import org.openapitools.model.DataResponseFlowStepFlow;
import org.openapitools.model.DataResponseJob;
import org.openapitools.model.DataResponseJobDeleteStatus;
import org.openapitools.model.DataResponseJsonNode;
import org.openapitools.model.DataResponseMapObjectObject;
import org.openapitools.model.DataResponseMapStringPlugin;
import org.openapitools.model.DataResponseSortingAsset;
import org.openapitools.model.DataResponseTenant;
import org.openapitools.model.DataResponseTenantFlowmodel;
import org.openapitools.model.DataResponseTenantsConfiguration;
import org.openapitools.model.FlowInstanceCountsFilterRequest;
import org.openapitools.model.FlowInstanceFilterRequest;
import org.openapitools.model.FlowModelContextFilterRequest;
import org.openapitools.model.FlowModelSnapshotFilterRequest;
import org.openapitools.model.FlowObjectsRequest;
import org.openapitools.model.FlowStepFilterRequest;
import org.openapitools.model.GenericResponse;
import org.openapitools.model.HostKey;
import org.openapitools.model.JobFilterRequest;
import org.openapitools.model.ListResponseCronJob;
import org.openapitools.model.ListResponseFlowModelContextSnapshot;
import org.openapitools.model.ListResponseHostKey;
import org.openapitools.model.ListResponseString;
import org.openapitools.model.ListResponseTenant;
import org.openapitools.model.ListResponseTenantFlowmodel;
import org.openapitools.model.ModelConfiguration;
import org.openapitools.model.PageResponseConfiguration;
import org.openapitools.model.PageResponseFlowInstance;
import org.openapitools.model.PageResponseFlowModelContextSnapshot;
import org.openapitools.model.PageResponseFlowModelSnapshot;
import org.openapitools.model.PageResponseFlowStep;
import org.openapitools.model.PageResponseJob;
import org.openapitools.model.PageResponseString;
import org.openapitools.model.PostSortRunOption;
import org.openapitools.model.PublicOrcConfiguration;
import org.openapitools.model.SecretInfo;
import org.openapitools.model.SimplePageRequest;
import org.openapitools.model.SortingDataFilterRequest;
import java.util.UUID;
import org.openapitools.model.UpdateState1Request;
import org.openapitools.model.UpdateStateRequest;
import org.openapitools.model.VersionConfig;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import jakarta.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2025-03-18T18:03:17.210646522Z[Europe/Lisbon]")
@Validated
@Tag(name = "configuration-controller", description = "the configuration-controller API")
public interface ApiApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * POST /api/v1/configuration/{domainId}
     *
     * @param domainId  (required)
     * @param modelConfiguration  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "addConfiguration",
        tags = { "configuration-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseConfiguration.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/configuration/{domainId}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseConfiguration> addConfiguration(
        @Size(min = 1, max = 255) @Parameter(name = "domainId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domainId") String domainId,
        @Parameter(name = "ModelConfiguration", description = "", required = true) @Valid @RequestBody ModelConfiguration modelConfiguration
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"configName\" : \"configName\", \"configDetails\" : { \"key\" : { \"values\" : [ { }, { } ], \"secretId\" : \"secretId\", \"value\" : \"value\" } }, \"active\" : true, \"configType\" : \"configType\", \"domainId\" : \"domainId\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/ssh/known-hosts/hostkey : Add key for host
     * Add key of provided host to known hosts.
     *
     * @param hostKey hostkey (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "addKeyForHost",
        summary = "Add key for host",
        description = "Add key of provided host to known hosts.",
        tags = { "ssh-connection-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/ssh/known-hosts/hostkey",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<GenericResponse> addKeyForHost(
        @Parameter(name = "HostKey", description = "hostkey", required = true) @Valid @RequestBody HostKey hostKey
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/cron-jobs/{domain} : Adds a new cron job
     * Adds a new Cron job 
     *
     * @param domain Domain id (required)
     * @param cronJob Cron job. It can apply to jobs or sort assets.&lt;br/&gt;name: Name of the cron job&lt;br/&gt;cronExpression: Cron expression in UNIX format that reflects when the cron job should be executed (the main cron orchestration cleanup job is executed hourly by default)&lt;br/&gt;cronType: Cron job type. Available values: markDeleted,wipe,startJob,updateExpirationTime,wipeSortingAssets,expireSortingAssets,sortingAndBundling. When wipe is selected the filter parameters are not used.&lt;br/&gt;startDateStart: Filter jobs matching started date after this date or sort assets created after this date. Date is a (yyyy-MM-dd format) String. It&#39;s also possible to use a negative number, representing the number of days before today.&lt;br/&gt;startDateEnd: Filter jobs matching started date before this date or sort assets created before this date. Date is a (yyyy-MM-dd format) String. It&#39;s also possible to use a negative number, representing the number of days before today.&lt;br/&gt;endDateStart: Filter jobs matching ended date after this date or sort assets modified after this date. Date is a (yyyy-MM-dd format) String. It&#39;s also possible to use a negative number, representing the number of days before today&lt;br/&gt;endDateEnd: Filter jobs matching ended date before this date or sort assets modified before this date. Date is a (yyyy-MM-dd format) String. It&#39;s also possible to use a negative number, representing the number of days before today&lt;br/&gt;statuses: Match jobs with any of these statuses. Possible values for jobs: complete,error,canceled,deleted&lt;br/&gt;sortingAssetStatuses: Match sorting assets with any of these statuses, possible values for sort assets: processed,waiting,expired,canceled&lt;br/&gt;serviceName: service to trigger for job&lt;br/&gt;channelName: input channel for pulling data&lt;br/&gt;inputPath: path parameter for the input channel&lt;br/&gt;headers: map of headers for starting job&lt;br/&gt;cacheTimeout: optional duration of file cache&lt;br/&gt;mode: Filter jobs matching this mode (ONDEMAND|BATCH)&lt;br/&gt;flowModelId: Filter sorting assets matching flow model id&lt;br/&gt;communicationIdList: Filter sorting assets matching the communication id (only one) or when running sorting&amp;bundling with appConsolidation equal to true, use the specified communications,&lt;br/&gt;when appConsolidation is false, only one communication id should be present&lt;br/&gt;preSortQueueName: Filter sorting assets matching pre sort queue name&lt;br/&gt;jobId: Filter sorting assets matching jobId&lt;br/&gt;postSortQueueName: queue name used in the post sort queue name&lt;br/&gt;appConsolidation: says whether multiple communications should be consolidated when running sorting&amp;bundling&lt;br/&gt;enabled: Determines whether the cron job should be triggered or not. Default value: true (required)
     * @return default response (status code 200)
     */
    @Operation(
        operationId = "addSchedule",
        summary = "Adds a new cron job",
        description = "Adds a new Cron job ",
        tags = { "cron-jobs-controller" },
        responses = {
            @ApiResponse(responseCode = "default", description = "default response", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseCronJob.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/cron-jobs/{domain}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseCronJob> addSchedule(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "CronJob", description = "Cron job. It can apply to jobs or sort assets.<br/>name: Name of the cron job<br/>cronExpression: Cron expression in UNIX format that reflects when the cron job should be executed (the main cron orchestration cleanup job is executed hourly by default)<br/>cronType: Cron job type. Available values: markDeleted,wipe,startJob,updateExpirationTime,wipeSortingAssets,expireSortingAssets,sortingAndBundling. When wipe is selected the filter parameters are not used.<br/>startDateStart: Filter jobs matching started date after this date or sort assets created after this date. Date is a (yyyy-MM-dd format) String. It's also possible to use a negative number, representing the number of days before today.<br/>startDateEnd: Filter jobs matching started date before this date or sort assets created before this date. Date is a (yyyy-MM-dd format) String. It's also possible to use a negative number, representing the number of days before today.<br/>endDateStart: Filter jobs matching ended date after this date or sort assets modified after this date. Date is a (yyyy-MM-dd format) String. It's also possible to use a negative number, representing the number of days before today<br/>endDateEnd: Filter jobs matching ended date before this date or sort assets modified before this date. Date is a (yyyy-MM-dd format) String. It's also possible to use a negative number, representing the number of days before today<br/>statuses: Match jobs with any of these statuses. Possible values for jobs: complete,error,canceled,deleted<br/>sortingAssetStatuses: Match sorting assets with any of these statuses, possible values for sort assets: processed,waiting,expired,canceled<br/>serviceName: service to trigger for job<br/>channelName: input channel for pulling data<br/>inputPath: path parameter for the input channel<br/>headers: map of headers for starting job<br/>cacheTimeout: optional duration of file cache<br/>mode: Filter jobs matching this mode (ONDEMAND|BATCH)<br/>flowModelId: Filter sorting assets matching flow model id<br/>communicationIdList: Filter sorting assets matching the communication id (only one) or when running sorting&bundling with appConsolidation equal to true, use the specified communications,<br/>when appConsolidation is false, only one communication id should be present<br/>preSortQueueName: Filter sorting assets matching pre sort queue name<br/>jobId: Filter sorting assets matching jobId<br/>postSortQueueName: queue name used in the post sort queue name<br/>appConsolidation: says whether multiple communications should be consolidated when running sorting&bundling<br/>enabled: Determines whether the cron job should be triggered or not. Default value: true", required = true) @Valid @RequestBody CronJob cronJob
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"dryRun\" : true, \"jobAvailable\" : true, \"endDateStart\" : \"endDateStart\", \"startDateEnd\" : \"startDateEnd\", \"enabled\" : true, \"mode\" : \"BATCH\", \"cronType\" : \"markDeleted\", \"sortingAssetStatuses\" : [ \"processed\", \"processed\" ], \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"appConsolidation\" : true, \"headers\" : { \"key\" : \"headers\" }, \"endDateEnd\" : \"endDateEnd\", \"serviceName\" : \"serviceName\", \"domainId\" : \"domainId\", \"communicationIdList\" : [ \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" ], \"cronExpression\" : \"cronExpression\", \"startDateStart\" : \"startDateStart\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"cacheTimeout\" : 0.8008282, \"inputPath\" : \"inputPath\", \"preSortQueueName\" : \"preSortQueueName\", \"name\" : \"name\", \"statuses\" : [ \"canceled\", \"canceled\" ], \"channelName\" : \"channelName\", \"postSortQueueName\" : \"postSortQueueName\" }, \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/runtime/cache : Clean input file cache
     * Delete all input file cache entries for files which are currently not in use.
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "cleanCache",
        summary = "Clean input file cache",
        description = "Delete all input file cache entries for files which are currently not in use.",
        tags = { "cache-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/runtime/cache",
        produces = { "application/json" }
    )
    
    default ResponseEntity<String> cleanCache(
        
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/ssh/known-hosts : Clear list of known hosts
     * Deletes all currently known hosts and their keys in this tenant context.
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "clearKnownHosts",
        summary = "Clear list of known hosts",
        description = "Deletes all currently known hosts and their keys in this tenant context.",
        tags = { "ssh-connection-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/ssh/known-hosts",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> clearKnownHosts(
        
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/tenants/{tenantId}
     *
     * @param tenantId  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "createTenantSchema",
        tags = { "tenant-admin-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataResponseTenant.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/tenants/{tenantId}",
        produces = { "application/json" }
    )
    
    default ResponseEntity<DataResponseTenant> createTenantSchema(
        @Size(min = 1, max = 40) @Parameter(name = "tenantId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("tenantId") String tenantId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/tenants/addTenant
     *
     * @param createTenantBody  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "createTenantWithExistingSchema",
        tags = { "tenant-admin-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataResponseTenant.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/tenants/addTenant",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseTenant> createTenantWithExistingSchema(
        @Parameter(name = "CreateTenantBody", description = "", required = true) @Valid @RequestBody CreateTenantBody createTenantBody
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/configuration/{domainId}/{configType}/{configName}
     *
     * @param domainId  (required)
     * @param configType Specify the configuration type. (required)
     * @param configName Specify the configuration name. (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "deleteConfiguration",
        tags = { "configuration-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/configuration/{domainId}/{configType}/{configName}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> deleteConfiguration(
        @Size(min = 1, max = 255) @Parameter(name = "domainId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domainId") String domainId,
        @Parameter(name = "configType", description = "Specify the configuration type.", required = true, in = ParameterIn.PATH) @PathVariable("configType") String configType,
        @Parameter(name = "configName", description = "Specify the configuration name.", required = true, in = ParameterIn.PATH) @PathVariable("configName") String configName
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/runtime/{domain}/flow-instances/{id}
     *
     * @param domain  (required)
     * @param id  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "deleteFlowInstance",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/runtime/{domain}/flow-instances/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> deleteFlowInstance(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/runtime/{domain}/jobs/{id} : Delete completed job
     * Delete completed job entry (including all flow instances) in runtime database and correspondent job working directory.
     *
     * @param domain Domain id (required)
     * @param id Job id (required)
     * @param force Force deletion of job entry in the database repository in case deletion of one or more files in the job working directory failed. (optional, default to false)
     * @return Deletion of one or more files failed (status code 409)
     */
    @Operation(
        operationId = "deleteJob",
        summary = "Delete completed job",
        description = "Delete completed job entry (including all flow instances) in runtime database and correspondent job working directory.",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "409", description = "Deletion of one or more files failed", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/runtime/{domain}/jobs/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<Void> deleteJob(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Job id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "force", description = "Force deletion of job entry in the database repository in case deletion of one or more files in the job working directory failed.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "force", required = false, defaultValue = "false") Boolean force
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/runtime/{domain}/jobs : Delete completed, canceled or failed jobs
     * Delete completed, canceled or failed job entries (including all flow instances) in runtime database and correspondent job working directories. &lt;br/&gt; Filter example: filter&#x3D;mode:BATCH;statuses:complete,error 
     *
     * @param domain Domain id (required)
     * @param force Force deletion of job entry in the database repository in case deletion of one or more files in the job working directory failed. (optional, default to false)
     * @param syncDelete Delete jobs and all job files synchronously. In case we run it asynchronously, the jobs will be marked as deleted and will be deleted asynchronously by an external job. This parameter only is available when using the key &#39;ids&#39; in the filter. (optional, default to false)
     * @param jobFilterRequest  (optional)
     * @return Deleted jobs successful (status code 200)
     *         or Bad request (status code 400)
     *         or Deletion of one or more files failed. (status code 409)
     */
    @Operation(
        operationId = "deleteJobs",
        summary = "Delete completed, canceled or failed jobs",
        description = "Delete completed, canceled or failed job entries (including all flow instances) in runtime database and correspondent job working directories. <br/> Filter example: filter=mode:BATCH;statuses:complete,error ",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Deleted jobs successful", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseJobDeleteStatus.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "409", description = "Deletion of one or more files failed.", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseJobDeleteStatus.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/runtime/{domain}/jobs",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseJobDeleteStatus> deleteJobs(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "force", description = "Force deletion of job entry in the database repository in case deletion of one or more files in the job working directory failed.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "force", required = false, defaultValue = "false") Boolean force,
        @Parameter(name = "syncDelete", description = "Delete jobs and all job files synchronously. In case we run it asynchronously, the jobs will be marked as deleted and will be deleted asynchronously by an external job. This parameter only is available when using the key 'ids' in the filter.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "syncDelete", required = false, defaultValue = "false") Boolean syncDelete,
        @Parameter(name = "JobFilterRequest", description = "") @Valid @RequestBody(required = false) JobFilterRequest jobFilterRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"failedDeleteJobs\" : { \"key\" : \"failedDeleteJobs\" }, \"successDeleteJobs\" : 0 }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/cron-jobs/{domain}/{cronJobId} : Deletes a cron job
     *
     * @param domain Domain id (required)
     * @param cronJobId CronJobId (required)
     * @return default response (status code 200)
     */
    @Operation(
        operationId = "deleteSchedule",
        summary = "Deletes a cron job",
        tags = { "cron-jobs-controller" },
        responses = {
            @ApiResponse(responseCode = "default", description = "default response", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/cron-jobs/{domain}/{cronJobId}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> deleteSchedule(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "cronJobId", description = "CronJobId", required = true, in = ParameterIn.PATH) @PathVariable("cronJobId") UUID cronJobId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/sortdata/{domain} : Delete sorting assets and set the jobs, instances and queued flow steps using those assets to error. The only possible parameters are domain (in the URL) and the mandatory filter
     * Sorting assets using synchronous mode is not included.  The filter value is a semicolon delimited list of key value pairs.  List values separate possible values with commas. These are the only keys possible, please ignore the parameters below this list: | Filter name                    | Filter value description                                                         | |--------------------------------|----------------------------------------------------------------------------------| | flowModelIds                   | Match sorting assets with these flow model ids.                                  | | communicationIds               | Match sorting assets with these communication ids.                               | | queueNames                     | Match sorting assets with these queue names.                                     | | externalIds                    | Match sorting assets with these external ids.                                    | | flowStepIds                    | Match sorting assets with these flow step ids.                                   | | ids                            | Match sorting assets with these sorting asset ids.                               | | jobIds                         | Match sorting assets with these job ids.                                         | | referenceIds                   | Match sorting assets with these reference ids.                                   | | sortSubflows                   | Match sorting assets with these sort sub flows.                                  | | metadata                       | Match sorting assets with these metadata values.                                 | | states                         | Match sorting assets with any of these states. Possible values: processed,waiting,expired,canceled,all| | customersCountFrom             | Match sorting assets having customer count from this number.                     | | customersCountTo               | Match sorting assets having customer count to this number.                       | | creationDateStart              | Match sorting assets created after this date. (yyyy-MM-dd format)                | | creationDateEnd                | Match sorting assets created before this date. (yyyy-MM-dd format)               | | lastModificationDateStart      | Match sorting assets modified after this date. (yyyy-MM-dd format)               | | lastModificationDateEnd        | Match sorting assets modified before this date. (yyyy-MM-dd format)              | Note: For following special characters in strings (applicable for queueNames, externalIds, sortSubflows, metadata) use:  : &amp;rarr; /colon/  ; &amp;rarr; /semi/  \\ &amp;rarr; /bsol/  Example - filter&#x3D;states:expired;queueNames:SortPrep
     *
     * @param domain Domain id (required)
     * @param sortingDataFilterRequest  (optional)
     * @return Success (status code 200)
     */
    @Operation(
        operationId = "deleteSortData",
        summary = "Delete sorting assets and set the jobs, instances and queued flow steps using those assets to error. The only possible parameters are domain (in the URL) and the mandatory filter",
        description = "Sorting assets using synchronous mode is not included.  The filter value is a semicolon delimited list of key value pairs.  List values separate possible values with commas. These are the only keys possible, please ignore the parameters below this list: | Filter name                    | Filter value description                                                         | |--------------------------------|----------------------------------------------------------------------------------| | flowModelIds                   | Match sorting assets with these flow model ids.                                  | | communicationIds               | Match sorting assets with these communication ids.                               | | queueNames                     | Match sorting assets with these queue names.                                     | | externalIds                    | Match sorting assets with these external ids.                                    | | flowStepIds                    | Match sorting assets with these flow step ids.                                   | | ids                            | Match sorting assets with these sorting asset ids.                               | | jobIds                         | Match sorting assets with these job ids.                                         | | referenceIds                   | Match sorting assets with these reference ids.                                   | | sortSubflows                   | Match sorting assets with these sort sub flows.                                  | | metadata                       | Match sorting assets with these metadata values.                                 | | states                         | Match sorting assets with any of these states. Possible values: processed,waiting,expired,canceled,all| | customersCountFrom             | Match sorting assets having customer count from this number.                     | | customersCountTo               | Match sorting assets having customer count to this number.                       | | creationDateStart              | Match sorting assets created after this date. (yyyy-MM-dd format)                | | creationDateEnd                | Match sorting assets created before this date. (yyyy-MM-dd format)               | | lastModificationDateStart      | Match sorting assets modified after this date. (yyyy-MM-dd format)               | | lastModificationDateEnd        | Match sorting assets modified before this date. (yyyy-MM-dd format)              | Note: For following special characters in strings (applicable for queueNames, externalIds, sortSubflows, metadata) use:  : &rarr; /colon/  ; &rarr; /semi/  \\ &rarr; /bsol/  Example - filter=states:expired;queueNames:SortPrep",
        tags = { "sort-data-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Success", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/sortdata/{domain}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<GenericResponse> deleteSortData(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "SortingDataFilterRequest", description = "") @Valid @RequestBody(required = false) SortingDataFilterRequest sortingDataFilterRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/sortdata/{domain}/{id} : Delete sorting asset and set the jobs, instances and queued flow steps using those assets to error. The only possible parameters are domain (in the URL) and the sorting asset id (in the URL)
     * Sorting assets using synchronous mode is not included.
     *
     * @param domain Domain id (required)
     * @param id Id (required)
     * @return Success (status code 200)
     */
    @Operation(
        operationId = "deleteSortData1",
        summary = "Delete sorting asset and set the jobs, instances and queued flow steps using those assets to error. The only possible parameters are domain (in the URL) and the sorting asset id (in the URL)",
        description = "Sorting assets using synchronous mode is not included.",
        tags = { "sort-data-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Success", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/sortdata/{domain}/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> deleteSortData1(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/version/api
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getApiVersion",
        tags = { "version-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/version/api",
        produces = { "application/json" }
    )
    
    default ResponseEntity<String> getApiVersion(
        
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/config
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getConfig1",
        tags = { "config-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = PublicOrcConfiguration.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/config",
        produces = { "application/json" }
    )
    
    default ResponseEntity<PublicOrcConfiguration> getConfig1(
        
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"baseSubscription\" : true, \"subscriptionEnabled\" : true, \"assuredDeliveryEnabled\" : true, \"flowScriptDebuggingEnabled\" : true }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/configuration/{domainId}/{configType}/{configName}
     *
     * @param domainId  (required)
     * @param configType Specify the configuration type. (required)
     * @param configName Specify the configuration name. (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getConfiguration",
        tags = { "configuration-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ModelConfiguration.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/configuration/{domainId}/{configType}/{configName}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<ModelConfiguration> getConfiguration(
        @Size(min = 1, max = 255) @Parameter(name = "domainId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domainId") String domainId,
        @Parameter(name = "configType", description = "Specify the configuration type.", required = true, in = ParameterIn.PATH) @PathVariable("configType") String configType,
        @Parameter(name = "configName", description = "Specify the configuration name.", required = true, in = ParameterIn.PATH) @PathVariable("configName") String configName
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"configName\" : \"configName\", \"configDetails\" : { \"key\" : { \"values\" : [ { }, { } ], \"secretId\" : \"secretId\", \"value\" : \"value\" } }, \"active\" : true, \"configType\" : \"configType\", \"domainId\" : \"domainId\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/configuration/{domainId} : Get all matching configurations
     * Get all configurations (no filter) or all the configurations matching the filter. &lt;br/&gt;Filter example: filter&#x3D;configType:myConfigType (domain is taken from the URL)
     *
     * @param filterRequest The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name          | Filter value description                                                                                       | |----------------------|----------------------------------------------------------------------------------------------------------------| | configType           | Match configurations with this configType.                                                                     | | configName           | Match configurations with this configName.                                                                     | (required)
     * @param domainId  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getConfigurations",
        summary = "Get all matching configurations",
        description = "Get all configurations (no filter) or all the configurations matching the filter. <br/>Filter example: filter=configType:myConfigType (domain is taken from the URL)",
        tags = { "configuration-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseConfiguration.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/configuration/{domainId}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseConfiguration> getConfigurations(
        @NotNull @Parameter(name = "filterRequest", description = "The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name          | Filter value description                                                                                       | |----------------------|----------------------------------------------------------------------------------------------------------------| | configType           | Match configurations with this configType.                                                                     | | configName           | Match configurations with this configName.                                                                     |", required = true, in = ParameterIn.QUERY) @Valid ConfigurationFilterRequest filterRequest,
        @Size(min = 1, max = 255) @Parameter(name = "domainId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domainId") String domainId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"configName\" : \"configName\", \"configDetails\" : { \"key\" : { \"values\" : [ { }, { } ], \"secretId\" : \"secretId\", \"value\" : \"value\" } }, \"active\" : true, \"configType\" : \"configType\", \"domainId\" : \"domainId\" }, { \"configName\" : \"configName\", \"configDetails\" : { \"key\" : { \"values\" : [ { }, { } ], \"secretId\" : \"secretId\", \"value\" : \"value\" } }, \"active\" : true, \"configType\" : \"configType\", \"domainId\" : \"domainId\" } ], \"page\" : { \"pageOffset\" : 6, \"totalPages\" : 5, \"currentPageNumber\" : 5, \"pageSize\" : 0, \"totalElements\" : 1 }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}/customer-artifacts/{customerId} : Get the customer artifacts in a zip file
     * Get the customer artifacts (1 or more) in a zip file, for the specified customer number (e.g. 1)
     *
     * @param domain  (required)
     * @param id  (required)
     * @param customerId  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getCustomerOutputArtifacts",
        summary = "Get the customer artifacts in a zip file",
        description = "Get the customer artifacts (1 or more) in a zip file, for the specified customer number (e.g. 1)",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/customer-artifacts/{customerId}"
    )
    
    default ResponseEntity<Void> getCustomerOutputArtifacts(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Size(min = 1, max = 512) @Parameter(name = "customerId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("customerId") String customerId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}/delivery-file/output-files
     *
     * @param domain  (required)
     * @param id  (required)
     * @param pageRequest  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getDeliveryFileOutputFiles",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseString.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/delivery-file/output-files",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseString> getDeliveryFileOutputFiles(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @NotNull @Parameter(name = "pageRequest", description = "", required = true, in = ParameterIn.QUERY) @Valid SimplePageRequest pageRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ \"data\", \"data\" ], \"page\" : { \"pageOffset\" : 6, \"totalPages\" : 5, \"currentPageNumber\" : 5, \"pageSize\" : 0, \"totalElements\" : 1 }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}/delivery-file/outputs
     *
     * @param domain  (required)
     * @param id  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getDeliveryFileOutputs",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseJsonNode.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/delivery-file/outputs",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseJsonNode> getDeliveryFileOutputs(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : \"{}\", \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}/artifact/{artifactName}
     *
     * @param domain  (required)
     * @param id  (required)
     * @param artifactName  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getDeliveryFileOutputs1",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Object.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/artifact/{artifactName}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<Object> getDeliveryFileOutputs1(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Size(min = 1, max = 512) @Parameter(name = "artifactName", description = "", required = true, in = ParameterIn.PATH) @PathVariable("artifactName") String artifactName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/flow-model-contexts/{domain} : Filter published flow contexts
     * Get a filtered list of current published flow contexts in this orchestration runtime environment context.&lt;br/&gt;Filter example: searchString:fulfillment
     *
     * @param filterRequest The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name          | Filter value description                                                                                       | |----------------------|----------------------------------------------------------------------------------------------------------------| | snapshotIds          | Match contexts with snapshotIds in this comma-separated list.                                                  | | dasIds               | Match snapshots created from any of these das ids.                                                             | | dasVersions          | Match snapshots where das version of original flow model is in this list. Useful with a singular id in dasIds. | | searchString         | Match snapshots with names matching this string.                                                               | | caseSensitive        | Specify if searches are case sensitive or not.                                                                 | | wholeWord            | Specify if searches match whole word or not.                                                                   | (required)
     * @param domain  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFilteredContexts",
        summary = "Filter published flow contexts",
        description = "Get a filtered list of current published flow contexts in this orchestration runtime environment context.<br/>Filter example: searchString:fulfillment",
        tags = { "flow-model-context-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseFlowModelContextSnapshot.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/flow-model-contexts/{domain}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseFlowModelContextSnapshot> getFilteredContexts(
        @NotNull @Parameter(name = "filterRequest", description = "The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name          | Filter value description                                                                                       | |----------------------|----------------------------------------------------------------------------------------------------------------| | snapshotIds          | Match contexts with snapshotIds in this comma-separated list.                                                  | | dasIds               | Match snapshots created from any of these das ids.                                                             | | dasVersions          | Match snapshots where das version of original flow model is in this list. Useful with a singular id in dasIds. | | searchString         | Match snapshots with names matching this string.                                                               | | caseSensitive        | Specify if searches are case sensitive or not.                                                                 | | wholeWord            | Specify if searches match whole word or not.                                                                   |", required = true, in = ParameterIn.QUERY) @Valid FlowModelContextFilterRequest filterRequest,
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"name\" : \"name\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"xmlContent\" : \"xmlContent\", \"version\" : 0, \"domainId\" : \"domainId\", \"content\" : \"content\" }, { \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"name\" : \"name\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"xmlContent\" : \"xmlContent\", \"version\" : 0, \"domainId\" : \"domainId\", \"content\" : \"content\" } ], \"page\" : { \"pageOffset\" : 6, \"totalPages\" : 5, \"currentPageNumber\" : 5, \"pageSize\" : 0, \"totalElements\" : 1 }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-instances/{id}
     *
     * @param domain  (required)
     * @param id  (required)
     * @param checkArtifacts  (optional, default to false)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowInstance",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseFlowInstance.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-instances/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseFlowInstance> getFlowInstance(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "checkArtifacts", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "checkArtifacts", required = false, defaultValue = "false") Boolean checkArtifacts
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"msg\" : \"msg\", \"flowModelSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"inputRetrievable\" : true, \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"executingLongRunningOp\" : true, \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-instances/{id}/collection-resources
     * Returns all collection resource ids used by any flow step for a flow instance
     *
     * @param domain  (required)
     * @param id  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowInstanceCollectionResources",
        description = "Returns all collection resource ids used by any flow step for a flow instance",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListResponseString.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-instances/{id}/collection-resources",
        produces = { "*/*" }
    )
    
    default ResponseEntity<ListResponseString> getFlowInstanceCollectionResources(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ \"data\", \"data\" ], \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-instances/{id}/input
     *
     * @param domain  (required)
     * @param id  (required)
     * @param download  (optional, default to false)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowInstanceInput",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Object.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-instances/{id}/input",
        produces = { "*/*" }
    )
    
    default ResponseEntity<Object> getFlowInstanceInput(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "download", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "download", required = false, defaultValue = "false") Boolean download
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-instances : Get flow instances
     * Get all flow instances (no filter) or all the flow instances matching the filter. &lt;br/&gt;Filter example: filter&#x3D;statuses:complete,error;externalId:specialJob 
     *
     * @param filterRequest The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name            | Filter value description                                                                               | |------------------------|--------------------------------------------------------------------------------------------------------| | ids                    | Match flow instances with ids in this comma-separated list.                                            | | flowModelId            | Match flow instances spawned from this flow model id (deprecated).                                     | | flowModelIds           | Match flow instances spawned from these flow model ids.(Note: When used along with flowModelId filter, ids from both filters are applied.)| | flowModelSnapshotIds   | Match flow instances spawned from any of these flow model snapshot ids.                                | | jobId                  | Match flow instances that ran as part of this job.                                                     | | externalId             | Match flow instances associated to this external id.                                                   | | statuses               | Match flow instances with any of these statuses. Possible values: canceled,started,complete,error,waiting,holding| | expiringDateStart      | Match flow instances expiring after this date. (yyyy-MM-dd format)                                     | | expiringDateEnd        | Match flow instances expiring before this date. (yyyy-MM-dd format)                                    | | flowModelTypes         | Match flow instances with any of these flow model types. Possible values: COMMUNICATION,ALERT,NOTIFICATION| | startDateStart         | Match flow instances started after this date. (yyyy-MM-dd format)                                      | | startDateEnd           | Match flow instances started before this date. (yyyy-MM-dd format)                                     | | endDateStart           | Match flow instances ended after this date. (yyyy-MM-dd format)                                        | | endDateEnd             | Match flow instances ended before this date. (yyyy-MM-dd format)                                       | | executingLongRunningOp | Match flow instances which are executing a long-running operation                                      | (required)
     * @param domain  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowInstances",
        summary = "Get flow instances",
        description = "Get all flow instances (no filter) or all the flow instances matching the filter. <br/>Filter example: filter=statuses:complete,error;externalId:specialJob ",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseFlowInstance.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-instances",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseFlowInstance> getFlowInstances(
        @NotNull @Parameter(name = "filterRequest", description = "The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name            | Filter value description                                                                               | |------------------------|--------------------------------------------------------------------------------------------------------| | ids                    | Match flow instances with ids in this comma-separated list.                                            | | flowModelId            | Match flow instances spawned from this flow model id (deprecated).                                     | | flowModelIds           | Match flow instances spawned from these flow model ids.(Note: When used along with flowModelId filter, ids from both filters are applied.)| | flowModelSnapshotIds   | Match flow instances spawned from any of these flow model snapshot ids.                                | | jobId                  | Match flow instances that ran as part of this job.                                                     | | externalId             | Match flow instances associated to this external id.                                                   | | statuses               | Match flow instances with any of these statuses. Possible values: canceled,started,complete,error,waiting,holding| | expiringDateStart      | Match flow instances expiring after this date. (yyyy-MM-dd format)                                     | | expiringDateEnd        | Match flow instances expiring before this date. (yyyy-MM-dd format)                                    | | flowModelTypes         | Match flow instances with any of these flow model types. Possible values: COMMUNICATION,ALERT,NOTIFICATION| | startDateStart         | Match flow instances started after this date. (yyyy-MM-dd format)                                      | | startDateEnd           | Match flow instances started before this date. (yyyy-MM-dd format)                                     | | endDateStart           | Match flow instances ended after this date. (yyyy-MM-dd format)                                        | | endDateEnd             | Match flow instances ended before this date. (yyyy-MM-dd format)                                       | | executingLongRunningOp | Match flow instances which are executing a long-running operation                                      |", required = true, in = ParameterIn.QUERY) @Valid FlowInstanceFilterRequest filterRequest,
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"msg\" : \"msg\", \"flowModelSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"inputRetrievable\" : true, \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"executingLongRunningOp\" : true, \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" }, { \"msg\" : \"msg\", \"flowModelSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"inputRetrievable\" : true, \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"executingLongRunningOp\" : true, \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" } ], \"page\" : { \"pageOffset\" : 6, \"totalPages\" : 5, \"currentPageNumber\" : 5, \"pageSize\" : 0, \"totalElements\" : 1 }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/flow-instances/associated-jobs
     *
     * @param domain  (required)
     * @param flowInstanceFilterRequest The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name            | Filter value description                                                                               | |------------------------|--------------------------------------------------------------------------------------------------------| | ids                    | Match flow instances with ids in this comma-separated list.                                            | | flowModelId            | Match flow instances spawned from this flow model id (deprecated).                                     | | flowModelIds           | Match flow instances spawned from these flow model ids.(Note: When used along with flowModelId filter, ids from both filters are applied.)| | flowModelSnapshotIds   | Match flow instances spawned from any of these flow model snapshot ids.                                | | jobId                  | Match flow instances that ran as part of this job.                                                     | | externalId             | Match flow instances associated to this external id.                                                   | | statuses               | Match flow instances with any of these statuses. Possible values: canceled,started,complete,error,waiting,holding| | expiringDateStart      | Match flow instances expiring after this date. (yyyy-MM-dd format)                                     | | expiringDateEnd        | Match flow instances expiring before this date. (yyyy-MM-dd format)                                    | | flowModelTypes         | Match flow instances with any of these flow model types. Possible values: COMMUNICATION,ALERT,NOTIFICATION| | startDateStart         | Match flow instances started after this date. (yyyy-MM-dd format)                                      | | startDateEnd           | Match flow instances started before this date. (yyyy-MM-dd format)                                     | | endDateStart           | Match flow instances ended after this date. (yyyy-MM-dd format)                                        | | endDateEnd             | Match flow instances ended before this date. (yyyy-MM-dd format)                                       | | executingLongRunningOp | Match flow instances which are executing a long-running operation                                      | (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowInstancesAndAssociatedJobs",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseFlowInstancesAndAssociatedJobs.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/flow-instances/associated-jobs",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseFlowInstancesAndAssociatedJobs> getFlowInstancesAndAssociatedJobs(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "FlowInstanceFilterRequest", description = "The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name            | Filter value description                                                                               | |------------------------|--------------------------------------------------------------------------------------------------------| | ids                    | Match flow instances with ids in this comma-separated list.                                            | | flowModelId            | Match flow instances spawned from this flow model id (deprecated).                                     | | flowModelIds           | Match flow instances spawned from these flow model ids.(Note: When used along with flowModelId filter, ids from both filters are applied.)| | flowModelSnapshotIds   | Match flow instances spawned from any of these flow model snapshot ids.                                | | jobId                  | Match flow instances that ran as part of this job.                                                     | | externalId             | Match flow instances associated to this external id.                                                   | | statuses               | Match flow instances with any of these statuses. Possible values: canceled,started,complete,error,waiting,holding| | expiringDateStart      | Match flow instances expiring after this date. (yyyy-MM-dd format)                                     | | expiringDateEnd        | Match flow instances expiring before this date. (yyyy-MM-dd format)                                    | | flowModelTypes         | Match flow instances with any of these flow model types. Possible values: COMMUNICATION,ALERT,NOTIFICATION| | startDateStart         | Match flow instances started after this date. (yyyy-MM-dd format)                                      | | startDateEnd           | Match flow instances started before this date. (yyyy-MM-dd format)                                     | | endDateStart           | Match flow instances ended after this date. (yyyy-MM-dd format)                                        | | endDateEnd             | Match flow instances ended before this date. (yyyy-MM-dd format)                                       | | executingLongRunningOp | Match flow instances which are executing a long-running operation                                      |", required = true) @Valid @RequestBody FlowInstanceFilterRequest flowInstanceFilterRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"flowInstances\" : { \"data\" : [ { \"msg\" : \"msg\", \"flowModelSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"inputRetrievable\" : true, \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"executingLongRunningOp\" : true, \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" }, { \"msg\" : \"msg\", \"flowModelSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"inputRetrievable\" : true, \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"executingLongRunningOp\" : true, \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" } ], \"page\" : { \"pageOffset\" : 6, \"totalPages\" : 5, \"currentPageNumber\" : 5, \"pageSize\" : 0, \"totalElements\" : 1 }, \"status\" : \"status\" }, \"jobs\" : { \"key\" : { \"msg\" : \"msg\", \"aggregatedFMCSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"channel\" : \"channel\", \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"mode\" : \"BATCH\", \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"triggeredBy\" : \"triggeredBy\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" } } }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/flow-instances/counts : Get flow instances counts
     * Get counts of flow instances grouped by start date and status. The counts will be automatically grouped by DAY/MONTH/YEAR based on available data.
     *
     * @param domain  (required)
     * @param flowInstanceCountsFilterRequest The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | Filter name          | Filter value description                                                                                             | |----------------------|----------------------------------------------------------------------------------------------------------------------| | flowModelIds         | Match flow instances spawned from these flow model ids.                                                              | | startDateStart       | Match flow instances started after this date. (yyyy-MM-ddThh:mm:ss.SSSZ format)                                      | | startDateEnd         | Match flow instances started before this date. (yyyy-MM-ddThh:mm:ss.SSSZ format)                                     | | fillMissingData      | Populate any missing data between grouped data ranges. If data is not found, counts would be returned as 0           | (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowInstancesCounts",
        summary = "Get flow instances counts",
        description = "Get counts of flow instances grouped by start date and status. The counts will be automatically grouped by DAY/MONTH/YEAR based on available data.",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseMapObjectObject.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/flow-instances/counts",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseMapObjectObject> getFlowInstancesCounts(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "FlowInstanceCountsFilterRequest", description = "The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | Filter name          | Filter value description                                                                                             | |----------------------|----------------------------------------------------------------------------------------------------------------------| | flowModelIds         | Match flow instances spawned from these flow model ids.                                                              | | startDateStart       | Match flow instances started after this date. (yyyy-MM-ddThh:mm:ss.SSSZ format)                                      | | startDateEnd         | Match flow instances started before this date. (yyyy-MM-ddThh:mm:ss.SSSZ format)                                     | | fillMissingData      | Populate any missing data between grouped data ranges. If data is not found, counts would be returned as 0           |", required = true) @Valid @RequestBody FlowInstanceCountsFilterRequest flowInstanceCountsFilterRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"key\" : \"{}\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-model-snapshots/{snapshotId}
     *
     * @param domain  (required)
     * @param snapshotId  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowModelSnapshot",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseFlowModelSnapshot.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-model-snapshots/{snapshotId}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseFlowModelSnapshot> getFlowModelSnapshot(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "snapshotId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("snapshotId") UUID snapshotId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"dasVersion\" : 0, \"publishedBy\" : \"publishedBy\", \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"domain\" : \"domain\", \"name\" : \"name\", \"publishDate\" : \"2000-01-23T04:56:07.000+00:00\", \"unpublishDate\" : \"2000-01-23T04:56:07.000+00:00\", \"description\" : \"description\", \"content\" : [ \"content\", \"content\" ], \"dasId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-model-snapshots
     *
     * @param domain  (required)
     * @param filterRequest  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowModelSnapshots",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseFlowModelSnapshot.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-model-snapshots",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseFlowModelSnapshot> getFlowModelSnapshots(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @NotNull @Parameter(name = "filterRequest", description = "", required = true, in = ParameterIn.QUERY) @Valid FlowModelSnapshotFilterRequest filterRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"dasVersion\" : 0, \"publishedBy\" : \"publishedBy\", \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"domain\" : \"domain\", \"name\" : \"name\", \"publishDate\" : \"2000-01-23T04:56:07.000+00:00\", \"unpublishDate\" : \"2000-01-23T04:56:07.000+00:00\", \"description\" : \"description\", \"content\" : [ \"content\", \"content\" ], \"dasId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" }, { \"dasVersion\" : 0, \"publishedBy\" : \"publishedBy\", \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"domain\" : \"domain\", \"name\" : \"name\", \"publishDate\" : \"2000-01-23T04:56:07.000+00:00\", \"unpublishDate\" : \"2000-01-23T04:56:07.000+00:00\", \"description\" : \"description\", \"content\" : [ \"content\", \"content\" ], \"dasId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" } ], \"page\" : { \"pageOffset\" : 6, \"totalPages\" : 5, \"currentPageNumber\" : 5, \"pageSize\" : 0, \"totalElements\" : 1 }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}
     *
     * @param domain  (required)
     * @param id  (required)
     * @param checkArtifacts  (optional, default to false)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowStep",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseFlowStep.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseFlowStep> getFlowStep(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "checkArtifacts", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "checkArtifacts", required = false, defaultValue = "false") Boolean checkArtifacts
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"msg\" : \"msg\", \"stepType\" : \"input\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"displayName\" : \"displayName\", \"previousStepId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"externalId\" : \"externalId\", \"flowInstanceId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"stepName\" : \"stepName\", \"queueDate\" : \"2000-01-23T04:56:07.000+00:00\", \"executeDate\" : \"2000-01-23T04:56:07.000+00:00\", \"deliveryFileRetrievable\" : true, \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"messageFileRetrievable\" : true, \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}/collection-resources
     * Returns all collection resource ids used by the specified flow step
     *
     * @param domain  (required)
     * @param id  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowStepCollectionResources",
        description = "Returns all collection resource ids used by the specified flow step",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListResponseString.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/collection-resources",
        produces = { "*/*" }
    )
    
    default ResponseEntity<ListResponseString> getFlowStepCollectionResources(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ \"data\", \"data\" ], \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}/delivery-file
     *
     * @param domain  (required)
     * @param id  (required)
     * @param download  (optional, default to false)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowStepDeliveryFile",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Object.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/delivery-file",
        produces = { "*/*" }
    )
    
    default ResponseEntity<Object> getFlowStepDeliveryFile(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "download", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "download", required = false, defaultValue = "false") Boolean download
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}/flow
     *
     * @param domain  (required)
     * @param id  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowStepFlow",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseFlowStepFlow.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/flow",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseFlowStepFlow> getFlowStepFlow(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"flowSteps\" : [ { \"msg\" : \"msg\", \"stepType\" : \"input\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"displayName\" : \"displayName\", \"previousStepId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"externalId\" : \"externalId\", \"flowInstanceId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"stepName\" : \"stepName\", \"queueDate\" : \"2000-01-23T04:56:07.000+00:00\", \"executeDate\" : \"2000-01-23T04:56:07.000+00:00\", \"deliveryFileRetrievable\" : true, \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"messageFileRetrievable\" : true, \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" }, { \"msg\" : \"msg\", \"stepType\" : \"input\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"displayName\" : \"displayName\", \"previousStepId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"externalId\" : \"externalId\", \"flowInstanceId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"stepName\" : \"stepName\", \"queueDate\" : \"2000-01-23T04:56:07.000+00:00\", \"executeDate\" : \"2000-01-23T04:56:07.000+00:00\", \"deliveryFileRetrievable\" : true, \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"messageFileRetrievable\" : true, \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" } ], \"inputChannel\" : \"inputChannel\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps/{id}/message-file
     *
     * @param domain  (required)
     * @param id  (required)
     * @param download  (optional, default to false)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowStepMessageFile",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Object.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/message-file",
        produces = { "*/*" }
    )
    
    default ResponseEntity<Object> getFlowStepMessageFile(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "download", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "download", required = false, defaultValue = "false") Boolean download
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/flow-steps : Get flow steps
     * Get all flow steps in the domain (no filter) or all the flow steps matching the filter. &lt;br/&gt;Filter example: name:FileInput;statuses:complete,error
     *
     * @param filterRequest The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name             | Filter value description                                                                       | |-------------------------|------------------------------------------------------------------------------------------------| | ids                     | Match flow steps with ids in this comma-separated list.                                        | | stepName                | Match resources with this stepName                                                             | | externalId              | Match flow steps associated to this external id.                                               | | previousStepId          | Match flow steps having this flow step as previous step id                                     | | flowInstanceId          | Match flow steps belonging to this flow instance                                               | | caseSensitive           | Specify if searches (stepName, displayName, externalId) are case sensitive or not.             | | statuses                | Match flow steps with any of these statuses. Possible values: canceled,created,waiting,holding,started,executed,complete,error| | stepTypes               | Match flow steps with any of these types. Possible values: input,communication,output,decider,processor,delay,hold,externalFlow,aggregator| | startDateStart          | Match flow steps started after this date. (yyyy-MM-dd format)                                  | | startDateEnd            | Match flow steps started before this date. (yyyy-MM-dd format)                                 | | endDateStart            | Match flow steps ended after this date. (yyyy-MM-dd format)                                    | | endDateEnd              | Match flow steps ended before this date. (yyyy-MM-dd format)                                   | | expiringDateStart       | Match flow steps expiring after this date. (yyyy-MM-dd format)                                 | | expiringDateEnd         | Match flow steps expiring before this date. (yyyy-MM-dd format)                                | | queueDateStart          | Match flow steps started after this date. (yyyy-MM-dd format)                                  | | queueDateEnd            | Match flow steps started before this date. (yyyy-MM-dd format)                                 | | executeDateStart        | Match flow steps ended after this date. (yyyy-MM-dd format)                                    | | executeDateEnd          | Match flow steps ended before this date. (yyyy-MM-dd format)                                   | | deliveryFileRetrievable | Match flow steps that have retrievable delivery files                                          | | displayName             | Match flow steps with this display name                                                        | (required)
     * @param domain  (required)
     * @param checkArtifacts  (optional, default to false)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getFlowSteps",
        summary = "Get flow steps",
        description = "Get all flow steps in the domain (no filter) or all the flow steps matching the filter. <br/>Filter example: name:FileInput;statuses:complete,error",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseFlowStep.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/flow-steps",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseFlowStep> getFlowSteps(
        @NotNull @Parameter(name = "filterRequest", description = "The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. Keys include: | filter name             | Filter value description                                                                       | |-------------------------|------------------------------------------------------------------------------------------------| | ids                     | Match flow steps with ids in this comma-separated list.                                        | | stepName                | Match resources with this stepName                                                             | | externalId              | Match flow steps associated to this external id.                                               | | previousStepId          | Match flow steps having this flow step as previous step id                                     | | flowInstanceId          | Match flow steps belonging to this flow instance                                               | | caseSensitive           | Specify if searches (stepName, displayName, externalId) are case sensitive or not.             | | statuses                | Match flow steps with any of these statuses. Possible values: canceled,created,waiting,holding,started,executed,complete,error| | stepTypes               | Match flow steps with any of these types. Possible values: input,communication,output,decider,processor,delay,hold,externalFlow,aggregator| | startDateStart          | Match flow steps started after this date. (yyyy-MM-dd format)                                  | | startDateEnd            | Match flow steps started before this date. (yyyy-MM-dd format)                                 | | endDateStart            | Match flow steps ended after this date. (yyyy-MM-dd format)                                    | | endDateEnd              | Match flow steps ended before this date. (yyyy-MM-dd format)                                   | | expiringDateStart       | Match flow steps expiring after this date. (yyyy-MM-dd format)                                 | | expiringDateEnd         | Match flow steps expiring before this date. (yyyy-MM-dd format)                                | | queueDateStart          | Match flow steps started after this date. (yyyy-MM-dd format)                                  | | queueDateEnd            | Match flow steps started before this date. (yyyy-MM-dd format)                                 | | executeDateStart        | Match flow steps ended after this date. (yyyy-MM-dd format)                                    | | executeDateEnd          | Match flow steps ended before this date. (yyyy-MM-dd format)                                   | | deliveryFileRetrievable | Match flow steps that have retrievable delivery files                                          | | displayName             | Match flow steps with this display name                                                        |", required = true, in = ParameterIn.QUERY) @Valid FlowStepFilterRequest filterRequest,
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "checkArtifacts", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "checkArtifacts", required = false, defaultValue = "false") Boolean checkArtifacts
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"msg\" : \"msg\", \"stepType\" : \"input\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"displayName\" : \"displayName\", \"previousStepId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"externalId\" : \"externalId\", \"flowInstanceId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"stepName\" : \"stepName\", \"queueDate\" : \"2000-01-23T04:56:07.000+00:00\", \"executeDate\" : \"2000-01-23T04:56:07.000+00:00\", \"deliveryFileRetrievable\" : true, \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"messageFileRetrievable\" : true, \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" }, { \"msg\" : \"msg\", \"stepType\" : \"input\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"displayName\" : \"displayName\", \"previousStepId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"externalId\" : \"externalId\", \"flowInstanceId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"stepName\" : \"stepName\", \"queueDate\" : \"2000-01-23T04:56:07.000+00:00\", \"executeDate\" : \"2000-01-23T04:56:07.000+00:00\", \"deliveryFileRetrievable\" : true, \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"messageFileRetrievable\" : true, \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" } ], \"page\" : { \"pageOffset\" : 6, \"totalPages\" : 5, \"currentPageNumber\" : 5, \"pageSize\" : 0, \"totalElements\" : 1 }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/jobs/{id}
     *
     * @param domain  (required)
     * @param id  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getJob",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseJob.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/jobs/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseJob> getJob(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"msg\" : \"msg\", \"aggregatedFMCSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"channel\" : \"channel\", \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"mode\" : \"BATCH\", \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"triggeredBy\" : \"triggeredBy\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/runtime/{domain}/jobs : Get jobs
     * Get all jobs (no filter) or all the jobs matching the filter. &lt;br/&gt;Filter example: filter&#x3D;mode:BATCH;statuses:complete,error 
     *
     * @param filterRequest The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. In deletion, if ids are used as key, the other keys are ignored. Keys include: | filter name             | Filter value description                                                                           | |-------------------------|----------------------------------------------------------------------------------------------------| | ids                     | Match jobs with ids in this comma-separated list. For deletion, the maximum number of ids is 100   | | channel                 | Match jobs using this channel                                                                      | | externalId              | Match jobs associated to this external id.                                                         | | triggeredBy             | Match jobs triggered by this user                                                                  | | statuses                | Match jobs with any of these statuses. Possible values: started,complete,error,waiting,holding,canceled,deleted| | startDateStart          | Match jobs started after this date. (yyyy-MM-dd format)                                            | | startDateEnd            | Match jobs started before this date. (yyyy-MM-dd format)                                           | | endDateStart            | Match jobs ended after this date. (yyyy-MM-dd format)                                              | | endDateEnd              | Match jobs ended before this date. (yyyy-MM-dd format)                                             | | expiringDateStart       | Match jobs expiring after this date. (yyyy-MM-dd format)                                           | | expiringDateEnd         | Match jobs expiring before this date. (yyyy-MM-dd format)                                          | | mode                    | Match jobs with modes in this list. Modes include: BATCH,ONDEMAND                      | | aggregatedFMCSnapshotIds| Match jobs with any of these aggregated flow context snapshot ids.                                 | | flowModelTypes          | Match jobs with any of these flowModelTypes. Possible values:COMMUNICATION,ALERT      | (required)
     * @param domain  (required)
     * @param fetchDeleted Show deleted jobs. If set to true, other states are ignored and only deleted jobs are returned. (optional, default to false)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getJobs",
        summary = "Get jobs",
        description = "Get all jobs (no filter) or all the jobs matching the filter. <br/>Filter example: filter=mode:BATCH;statuses:complete,error ",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseJob.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/runtime/{domain}/jobs",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseJob> getJobs(
        @NotNull @Parameter(name = "filterRequest", description = "The filter value is a semicolon delimited list of key value pairs. List values separate possible values with commas. In deletion, if ids are used as key, the other keys are ignored. Keys include: | filter name             | Filter value description                                                                           | |-------------------------|----------------------------------------------------------------------------------------------------| | ids                     | Match jobs with ids in this comma-separated list. For deletion, the maximum number of ids is 100   | | channel                 | Match jobs using this channel                                                                      | | externalId              | Match jobs associated to this external id.                                                         | | triggeredBy             | Match jobs triggered by this user                                                                  | | statuses                | Match jobs with any of these statuses. Possible values: started,complete,error,waiting,holding,canceled,deleted| | startDateStart          | Match jobs started after this date. (yyyy-MM-dd format)                                            | | startDateEnd            | Match jobs started before this date. (yyyy-MM-dd format)                                           | | endDateStart            | Match jobs ended after this date. (yyyy-MM-dd format)                                              | | endDateEnd              | Match jobs ended before this date. (yyyy-MM-dd format)                                             | | expiringDateStart       | Match jobs expiring after this date. (yyyy-MM-dd format)                                           | | expiringDateEnd         | Match jobs expiring before this date. (yyyy-MM-dd format)                                          | | mode                    | Match jobs with modes in this list. Modes include: BATCH,ONDEMAND                      | | aggregatedFMCSnapshotIds| Match jobs with any of these aggregated flow context snapshot ids.                                 | | flowModelTypes          | Match jobs with any of these flowModelTypes. Possible values:COMMUNICATION,ALERT      |", required = true, in = ParameterIn.QUERY) @Valid JobFilterRequest filterRequest,
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "fetchDeleted", description = "Show deleted jobs. If set to true, other states are ignored and only deleted jobs are returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fetchDeleted", required = false, defaultValue = "false") Boolean fetchDeleted
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"msg\" : \"msg\", \"aggregatedFMCSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"channel\" : \"channel\", \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"mode\" : \"BATCH\", \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"triggeredBy\" : \"triggeredBy\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" }, { \"msg\" : \"msg\", \"aggregatedFMCSnapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"endDate\" : \"2000-01-23T04:56:07.000+00:00\", \"channel\" : \"channel\", \"externalId\" : \"externalId\", \"domainId\" : \"domainId\", \"mode\" : \"BATCH\", \"flowModelType\" : \"COMMUNICATION\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"startDate\" : \"2000-01-23T04:56:07.000+00:00\", \"status\" : \"canceled\", \"triggeredBy\" : \"triggeredBy\", \"expirationDate\" : \"2000-01-23T04:56:07.000+00:00\" } ], \"page\" : { \"pageOffset\" : 6, \"totalPages\" : 5, \"currentPageNumber\" : 5, \"pageSize\" : 0, \"totalElements\" : 1 }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/ssh/known-hosts/hostkey : Get key for host
     * Requests a fresh key for specified host.
     *
     * @param host Specifies host name (required)
     * @param port Specifies port (optional, default to 22)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getKeyForHost",
        summary = "Get key for host",
        description = "Requests a fresh key for specified host.",
        tags = { "ssh-connection-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/ssh/known-hosts/hostkey",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> getKeyForHost(
        @NotNull @Parameter(name = "host", description = "Specifies host name", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "host", required = true) String host,
        @Parameter(name = "port", description = "Specifies port", in = ParameterIn.QUERY) @Valid @RequestParam(value = "port", required = false, defaultValue = "22") Integer port
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/plugins : Get a list of plugins
     * Returns a list of descriptions for all currently deployed custom plugins
     *
     * @param locale Requested localization for plugins if available. Will return base localization otherwise. (optional)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getPlugins",
        summary = "Get a list of plugins",
        description = "Returns a list of descriptions for all currently deployed custom plugins",
        tags = { "custom-plugins-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataResponseMapStringPlugin.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/plugins",
        produces = { "application/json" }
    )
    
    default ResponseEntity<DataResponseMapStringPlugin> getPlugins(
        @Parameter(name = "locale", description = "Requested localization for plugins if available. Will return base localization otherwise.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locale", required = false) String locale
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : { \"key\" : { \"iconType\" : \"iconType\", \"custom\" : true, \"icon\" : \"icon\", \"description\" : \"description\", \"id\" : \"id\", \"label\" : \"label\", \"locale\" : \"locale\", \"version\" : \"version\", \"config\" : { \"secureChannelHostVerificationRequired\" : [ \"secureChannelHostVerificationRequired\", \"secureChannelHostVerificationRequired\" ], \"authenticationProvided\" : true, \"analyticsSupported\" : true, \"outcomeMappingSupported\" : true, \"additionalFilesInputHandlingOnly\" : true, \"validators\" : \"{}\", \"restrictedUseDefault\" : true, \"outcomeMappingRequired\" : true, \"assuredDeliverySupported\" : true, \"jobExpirationSupported\" : true, \"steps\" : [ { \"visible\" : \"visible\", \"id\" : \"id\", \"title\" : \"title\", \"properties\" : [ { \"headers\" : true, \"visible\" : \"visible\", \"defaultValue\" : \"defaultValue\", \"validators\" : [ \"validators\", \"validators\" ], \"validator\" : \"validator\", \"dynamicOptions\" : { \"filter\" : \"filter\", \"type\" : \"type\" }, \"label\" : \"label\", \"type\" : \"type\", \"rows\" : 5, \"maxListRows\" : 1, \"required\" : true, \"instruction\" : \"instruction\", \"options\" : [ { \"id\" : \"id\", \"label\" : \"label\" }, { \"id\" : \"id\", \"label\" : \"label\" } ], \"migration\" : { \"format\" : \"format\", \"source\" : \"source\" }, \"disabled\" : true, \"id\" : \"id\", \"placeholder\" : \"placeholder\", \"minListRows\" : 6, \"maxLength\" : 0 }, { \"headers\" : true, \"visible\" : \"visible\", \"defaultValue\" : \"defaultValue\", \"validators\" : [ \"validators\", \"validators\" ], \"validator\" : \"validator\", \"dynamicOptions\" : { \"filter\" : \"filter\", \"type\" : \"type\" }, \"label\" : \"label\", \"type\" : \"type\", \"rows\" : 5, \"maxListRows\" : 1, \"required\" : true, \"instruction\" : \"instruction\", \"options\" : [ { \"id\" : \"id\", \"label\" : \"label\" }, { \"id\" : \"id\", \"label\" : \"label\" } ], \"migration\" : { \"format\" : \"format\", \"source\" : \"source\" }, \"disabled\" : true, \"id\" : \"id\", \"placeholder\" : \"placeholder\", \"minListRows\" : 6, \"maxLength\" : 0 } ] }, { \"visible\" : \"visible\", \"id\" : \"id\", \"title\" : \"title\", \"properties\" : [ { \"headers\" : true, \"visible\" : \"visible\", \"defaultValue\" : \"defaultValue\", \"validators\" : [ \"validators\", \"validators\" ], \"validator\" : \"validator\", \"dynamicOptions\" : { \"filter\" : \"filter\", \"type\" : \"type\" }, \"label\" : \"label\", \"type\" : \"type\", \"rows\" : 5, \"maxListRows\" : 1, \"required\" : true, \"instruction\" : \"instruction\", \"options\" : [ { \"id\" : \"id\", \"label\" : \"label\" }, { \"id\" : \"id\", \"label\" : \"label\" } ], \"migration\" : { \"format\" : \"format\", \"source\" : \"source\" }, \"disabled\" : true, \"id\" : \"id\", \"placeholder\" : \"placeholder\", \"minListRows\" : 6, \"maxLength\" : 0 }, { \"headers\" : true, \"visible\" : \"visible\", \"defaultValue\" : \"defaultValue\", \"validators\" : [ \"validators\", \"validators\" ], \"validator\" : \"validator\", \"dynamicOptions\" : { \"filter\" : \"filter\", \"type\" : \"type\" }, \"label\" : \"label\", \"type\" : \"type\", \"rows\" : 5, \"maxListRows\" : 1, \"required\" : true, \"instruction\" : \"instruction\", \"options\" : [ { \"id\" : \"id\", \"label\" : \"label\" }, { \"id\" : \"id\", \"label\" : \"label\" } ], \"migration\" : { \"format\" : \"format\", \"source\" : \"source\" }, \"disabled\" : true, \"id\" : \"id\", \"placeholder\" : \"placeholder\", \"minListRows\" : 6, \"maxLength\" : 0 } ] } ], \"additionalFilesInputHandlingSupported\" : true }, \"group\" : \"group\", \"uiComponent\" : \"uiComponent\" } }, \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/flow-model-contexts/{domain}/published/{flowModelContextId} : Get published flow context content
     * Get content of specified published flow context version from orchestration runtime environment.
     *
     * @param domain Domain id (required)
     * @param flowModelContextId Flow context id (required)
     * @return Content of flow model context returned successfully (status code 200)
     *         or Flow model context not found (status code 404)
     */
    @Operation(
        operationId = "getPublished",
        summary = "Get published flow context content",
        description = "Get content of specified published flow context version from orchestration runtime environment.",
        tags = { "flow-model-context-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Content of flow model context returned successfully", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseFlowModelContextSnapshot.class))
            }),
            @ApiResponse(responseCode = "404", description = "Flow model context not found", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/flow-model-contexts/{domain}/published/{flowModelContextId}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseFlowModelContextSnapshot> getPublished(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "flowModelContextId", description = "Flow context id", required = true, in = ParameterIn.PATH) @PathVariable("flowModelContextId") UUID flowModelContextId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"name\" : \"name\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"xmlContent\" : \"xmlContent\", \"version\" : 0, \"domainId\" : \"domainId\", \"content\" : \"content\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/sortdata/{domain}/{id} : Get sorting asset. The only possible parameters are domain (in the URL) and the id (in the URL)
     * Sorting assets using synchronous mode is not included.
     *
     * @param domain Domain id (required)
     * @param id Id (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getSortingAsset",
        summary = "Get sorting asset. The only possible parameters are domain (in the URL) and the id (in the URL)",
        description = "Sorting assets using synchronous mode is not included.",
        tags = { "sort-data-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseSortingAsset.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/sortdata/{domain}/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseSortingAsset> getSortingAsset(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"metadata\" : \"metadata\", \"communicationId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"sortSubflow\" : \"sortSubflow\", \"externalId\" : \"externalId\", \"subpackageIds\" : \"subpackageIds\", \"flowStepId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"creationDate\" : \"2000-01-23T04:56:07.000+00:00\", \"referenceId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"lastModificationDate\" : \"2000-01-23T04:56:07.000+00:00\", \"queueName\" : \"queueName\", \"customersCount\" : 0, \"subPackageIds\" : \"subPackageIds\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"state\" : \"processed\", \"engineInfo\" : \"engineInfo\" }, \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/sortdata/{domain}/{id}/content : Get content of sorting assets. Possible parameters are domain (in the URL) and the id (in the URL) of the sorting asset.
     * Sorting assets using synchronous mode is not included.
     *
     * @param domain Domain id (required)
     * @param id Id (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getSortingAssetContent",
        summary = "Get content of sorting assets. Possible parameters are domain (in the URL) and the id (in the URL) of the sorting asset.",
        description = "Sorting assets using synchronous mode is not included.",
        tags = { "sort-data-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/sortdata/{domain}/{id}/content",
        produces = { "application/exstream-sort-index" }
    )
    
    default ResponseEntity<Void> getSortingAssetContent(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/tenants/{tenantId}
     *
     * @param tenantId  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getTenant",
        tags = { "tenant-admin-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataResponseTenant.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/tenants/{tenantId}",
        produces = { "application/json" }
    )
    
    default ResponseEntity<DataResponseTenant> getTenant(
        @Parameter(name = "tenantId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("tenantId") String tenantId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/tenants/configuration
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getTenantConfiguration",
        tags = { "tenant-admin-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataResponseTenantsConfiguration.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/tenants/configuration",
        produces = { "application/json" }
    )
    
    default ResponseEntity<DataResponseTenantsConfiguration> getTenantConfiguration(
        
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : { \"autoSchemaManagement\" : true }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/tenants
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getTenants",
        tags = { "tenant-admin-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ListResponseTenant.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/tenants",
        produces = { "application/json" }
    )
    
    default ResponseEntity<ListResponseTenant> getTenants(
        
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : [ { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" }, { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" } ], \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/version
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "getVersion1",
        tags = { "version-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = VersionConfig.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/version",
        produces = { "application/json" }
    )
    
    default ResponseEntity<VersionConfig> getVersion1(
        
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"patch\" : \"patch\", \"major\" : \"major\", \"minor\" : \"minor\", \"versionString\" : \"versionString\", \"apiIdentifier\" : \"apiIdentifier\", \"details\" : { \"git\" : { \"commits\" : \"commits\", \"tag\" : \"tag\", \"branch\" : \"branch\", \"hash\" : \"hash\" }, \"appName\" : \"appName\", \"buildNumber\" : \"buildNumber\", \"timestamp\" : \"timestamp\" } }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/flow-models/{domain}/{flowModelId}/deletable : Says whether this flow model can be safely deleted
     * It will not be deletable if it is published in at least one domain, maybe one to which the user has no access
     *
     * @param domain Domain id (required)
     * @param flowModelId Flow model id (required)
     * @param version Specify version (optional). If omitted, any version will match. (optional)
     * @return Says whether the flow model can be safely deleted or not (status code 200)
     */
    @Operation(
        operationId = "isDeletable",
        summary = "Says whether this flow model can be safely deleted",
        description = "It will not be deletable if it is published in at least one domain, maybe one to which the user has no access",
        tags = { "flow-model-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Says whether the flow model can be safely deleted or not", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseDeletableResource.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/flow-models/{domain}/{flowModelId}/deletable",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseDeletableResource> isDeletable(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "flowModelId", description = "Flow model id", required = true, in = ParameterIn.PATH) @PathVariable("flowModelId") UUID flowModelId,
        @Parameter(name = "version", description = "Specify version (optional). If omitted, any version will match.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"deletable\" : true }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/flow-model-contexts/{domain}/{flowContextId}/deletable : Says whether this flow context can be safely deleted
     * It will not be deletable if it is published in at least one domain, maybe one to which the user has no access
     *
     * @param domain Domain id (required)
     * @param flowContextId Flow context id (required)
     * @param version Specify version (optional). If omitted, any version will match. (optional)
     * @return Says whether the flow context can be safely deleted or not (status code 200)
     */
    @Operation(
        operationId = "isDeletable1",
        summary = "Says whether this flow context can be safely deleted",
        description = "It will not be deletable if it is published in at least one domain, maybe one to which the user has no access",
        tags = { "flow-model-context-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Says whether the flow context can be safely deleted or not", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseDeletableResource.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/flow-model-contexts/{domain}/{flowContextId}/deletable",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseDeletableResource> isDeletable1(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "flowContextId", description = "Flow context id", required = true, in = ParameterIn.PATH) @PathVariable("flowContextId") UUID flowContextId,
        @Parameter(name = "version", description = "Specify version (optional). If omitted, any version will match.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"deletable\" : true }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/ssh/known-hosts : Get a list of known hosts
     * Returns a list of all currently known hosts and their keys in this tenant context.
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "listKnownHosts",
        summary = "Get a list of known hosts",
        description = "Returns a list of all currently known hosts and their keys in this tenant context.",
        tags = { "ssh-connection-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListResponseHostKey.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/ssh/known-hosts",
        produces = { "*/*" }
    )
    
    default ResponseEntity<ListResponseHostKey> listKnownHosts(
        
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"host\" : \"host\", \"type\" : \"type\", \"key\" : \"key\" }, { \"host\" : \"host\", \"type\" : \"type\", \"key\" : \"key\" } ], \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/flow-models/{domain}/published : List published flow models
     * Get a list of current published flow models in this orchestration runtime environment context.&lt;br /&gt;&lt;b&gt;Version 20.4.0:&lt;/b&gt; Flow model &#39;&lt;i&gt;version&lt;/i&gt;&#39; property changed from datatype string to integer in response body.
     *
     * @param domain Domain id (required)
     * @return List of published flow models, the list may be empty (status code 200)
     */
    @Operation(
        operationId = "listPublished",
        summary = "List published flow models",
        description = "Get a list of current published flow models in this orchestration runtime environment context.<br /><b>Version 20.4.0:</b> Flow model '<i>version</i>' property changed from datatype string to integer in response body.",
        tags = { "flow-model-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "List of published flow models, the list may be empty", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListResponseTenantFlowmodel.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/flow-models/{domain}/published",
        produces = { "*/*" }
    )
    
    default ResponseEntity<ListResponseTenantFlowmodel> listPublished(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"sdpermissions\" : [ \"sdpermissions\", \"sdpermissions\" ], \"nodes\" : [ { \"internal\" : true, \"metadata\" : [ { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" }, { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" } ], \"instanceId\" : \"instanceId\", \"subtype\" : \"directory_channel\", \"displayName\" : \"displayName\", \"x\" : 1, \"y\" : 5, \"attributes\" : [ { \"name\" : \"name\", \"value\" : \"value\" }, { \"name\" : \"name\", \"value\" : \"value\" } ], \"id\" : \"id\", \"type\" : \"input\", \"connections\" : [ { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" }, { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" } ] }, { \"internal\" : true, \"metadata\" : [ { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" }, { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" } ], \"instanceId\" : \"instanceId\", \"subtype\" : \"directory_channel\", \"displayName\" : \"displayName\", \"x\" : 1, \"y\" : 5, \"attributes\" : [ { \"name\" : \"name\", \"value\" : \"value\" }, { \"name\" : \"name\", \"value\" : \"value\" } ], \"id\" : \"id\", \"type\" : \"input\", \"connections\" : [ { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" }, { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" } ] } ], \"lockedBy\" : \"lockedBy\", \"latestVersion\" : true, \"stateComment\" : \"stateComment\", \"name\" : \"name\", \"description\" : \"description\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"state\" : \"DRAFT\", \"type\" : \"COMMUNICATION\", \"version\" : 6, \"revision\" : 0 }, { \"sdpermissions\" : [ \"sdpermissions\", \"sdpermissions\" ], \"nodes\" : [ { \"internal\" : true, \"metadata\" : [ { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" }, { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" } ], \"instanceId\" : \"instanceId\", \"subtype\" : \"directory_channel\", \"displayName\" : \"displayName\", \"x\" : 1, \"y\" : 5, \"attributes\" : [ { \"name\" : \"name\", \"value\" : \"value\" }, { \"name\" : \"name\", \"value\" : \"value\" } ], \"id\" : \"id\", \"type\" : \"input\", \"connections\" : [ { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" }, { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" } ] }, { \"internal\" : true, \"metadata\" : [ { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" }, { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" } ], \"instanceId\" : \"instanceId\", \"subtype\" : \"directory_channel\", \"displayName\" : \"displayName\", \"x\" : 1, \"y\" : 5, \"attributes\" : [ { \"name\" : \"name\", \"value\" : \"value\" }, { \"name\" : \"name\", \"value\" : \"value\" } ], \"id\" : \"id\", \"type\" : \"input\", \"connections\" : [ { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" }, { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" } ] } ], \"lockedBy\" : \"lockedBy\", \"latestVersion\" : true, \"stateComment\" : \"stateComment\", \"name\" : \"name\", \"description\" : \"description\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"state\" : \"DRAFT\", \"type\" : \"COMMUNICATION\", \"version\" : 6, \"revision\" : 0 } ], \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/flow-model-contexts/{domain}/published : List published flow contexts
     * Get a list of current published flow contexts in this orchestration runtime environment context.
     *
     * @param domain Domain id (required)
     * @return List of published flow model contexts, the list may be empty (status code 200)
     */
    @Operation(
        operationId = "listPublished1",
        summary = "List published flow contexts",
        description = "Get a list of current published flow contexts in this orchestration runtime environment context.",
        tags = { "flow-model-context-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "List of published flow model contexts, the list may be empty", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListResponseFlowModelContextSnapshot.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/flow-model-contexts/{domain}/published",
        produces = { "*/*" }
    )
    
    default ResponseEntity<ListResponseFlowModelContextSnapshot> listPublished1(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : [ { \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"name\" : \"name\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"xmlContent\" : \"xmlContent\", \"version\" : 0, \"domainId\" : \"domainId\", \"content\" : \"content\" }, { \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"name\" : \"name\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"xmlContent\" : \"xmlContent\", \"version\" : 0, \"domainId\" : \"domainId\", \"content\" : \"content\" } ], \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/cron-jobs/{domain} : List all cron jobs
     *
     * @param domain Domain id (required)
     * @return default response (status code 200)
     */
    @Operation(
        operationId = "listSchedules",
        summary = "List all cron jobs",
        tags = { "cron-jobs-controller" },
        responses = {
            @ApiResponse(responseCode = "default", description = "default response", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ListResponseCronJob.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/cron-jobs/{domain}",
        produces = { "application/json" }
    )
    
    default ResponseEntity<ListResponseCronJob> listSchedules(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : [ { \"dryRun\" : true, \"jobAvailable\" : true, \"endDateStart\" : \"endDateStart\", \"startDateEnd\" : \"startDateEnd\", \"enabled\" : true, \"mode\" : \"BATCH\", \"cronType\" : \"markDeleted\", \"sortingAssetStatuses\" : [ \"processed\", \"processed\" ], \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"appConsolidation\" : true, \"headers\" : { \"key\" : \"headers\" }, \"endDateEnd\" : \"endDateEnd\", \"serviceName\" : \"serviceName\", \"domainId\" : \"domainId\", \"communicationIdList\" : [ \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" ], \"cronExpression\" : \"cronExpression\", \"startDateStart\" : \"startDateStart\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"cacheTimeout\" : 0.8008282, \"inputPath\" : \"inputPath\", \"preSortQueueName\" : \"preSortQueueName\", \"name\" : \"name\", \"statuses\" : [ \"canceled\", \"canceled\" ], \"channelName\" : \"channelName\", \"postSortQueueName\" : \"postSortQueueName\" }, { \"dryRun\" : true, \"jobAvailable\" : true, \"endDateStart\" : \"endDateStart\", \"startDateEnd\" : \"startDateEnd\", \"enabled\" : true, \"mode\" : \"BATCH\", \"cronType\" : \"markDeleted\", \"sortingAssetStatuses\" : [ \"processed\", \"processed\" ], \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"appConsolidation\" : true, \"headers\" : { \"key\" : \"headers\" }, \"endDateEnd\" : \"endDateEnd\", \"serviceName\" : \"serviceName\", \"domainId\" : \"domainId\", \"communicationIdList\" : [ \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" ], \"cronExpression\" : \"cronExpression\", \"startDateStart\" : \"startDateStart\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"cacheTimeout\" : 0.8008282, \"inputPath\" : \"inputPath\", \"preSortQueueName\" : \"preSortQueueName\", \"name\" : \"name\", \"statuses\" : [ \"canceled\", \"canceled\" ], \"channelName\" : \"channelName\", \"postSortQueueName\" : \"postSortQueueName\" } ], \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/sortdata/{domain} : List sorting assets. Possible parameters are domain (in the URL) and the optional parameters filter,count,offset and sort
     * Sorting assets using synchronous mode is not included.  The filter value is a semicolon delimited list of key value pairs.  List values separate possible values with commas. These are the only keys possible, please ignore the parameters below this list: | Filter name                    | Filter value description                                                         | |--------------------------------|----------------------------------------------------------------------------------| | flowModelIds                   | Match sorting assets with these flow model ids.                                  | | communicationIds               | Match sorting assets with these communication ids.                               | | queueNames                     | Match sorting assets with these queue names.                                     | | externalIds                    | Match sorting assets with these external ids.                                    | | flowStepIds                    | Match sorting assets with these flow step ids.                                   | | ids                            | Match sorting assets with these sorting asset ids.                               | | jobIds                         | Match sorting assets with these job ids.                                         | | referenceIds                   | Match sorting assets with these reference ids.                                   | | sortSubflows                   | Match sorting assets with these sort sub flows.                                  | | metadata                       | Match sorting assets with these metadata values.                                 | | states                         | Match sorting assets with any of these states. Possible values: processed,waiting,expired,canceled,all| | customersCountFrom             | Match sorting assets having customer count from this number.                     | | customersCountTo               | Match sorting assets having customer count to this number.                       | | creationDateStart              | Match sorting assets created after this date. (yyyy-MM-dd format)                | | creationDateEnd                | Match sorting assets created before this date. (yyyy-MM-dd format)               | | lastModificationDateStart      | Match sorting assets modified after this date. (yyyy-MM-dd format)               | | lastModificationDateEnd        | Match sorting assets modified before this date. (yyyy-MM-dd format)              | Note: For following special characters in strings (applicable for queueNames, externalIds, sortSubflows, metadata) use:  : &amp;rarr; /colon/  ; &amp;rarr; /semi/  \\ &amp;rarr; /bsol/  Example - filter&#x3D;queueNames:SortPrep&amp;count&#x3D;10&amp;offset&#x3D;0
     *
     * @param domain Domain id (required)
     * @param filterRequest Use the optional filter parameter to decide which sorting assets should be listed (ALL of them if no filter specified) (required)
     * @return Success (status code 200)
     */
    @Operation(
        operationId = "listSortingAssets",
        summary = "List sorting assets. Possible parameters are domain (in the URL) and the optional parameters filter,count,offset and sort",
        description = "Sorting assets using synchronous mode is not included.  The filter value is a semicolon delimited list of key value pairs.  List values separate possible values with commas. These are the only keys possible, please ignore the parameters below this list: | Filter name                    | Filter value description                                                         | |--------------------------------|----------------------------------------------------------------------------------| | flowModelIds                   | Match sorting assets with these flow model ids.                                  | | communicationIds               | Match sorting assets with these communication ids.                               | | queueNames                     | Match sorting assets with these queue names.                                     | | externalIds                    | Match sorting assets with these external ids.                                    | | flowStepIds                    | Match sorting assets with these flow step ids.                                   | | ids                            | Match sorting assets with these sorting asset ids.                               | | jobIds                         | Match sorting assets with these job ids.                                         | | referenceIds                   | Match sorting assets with these reference ids.                                   | | sortSubflows                   | Match sorting assets with these sort sub flows.                                  | | metadata                       | Match sorting assets with these metadata values.                                 | | states                         | Match sorting assets with any of these states. Possible values: processed,waiting,expired,canceled,all| | customersCountFrom             | Match sorting assets having customer count from this number.                     | | customersCountTo               | Match sorting assets having customer count to this number.                       | | creationDateStart              | Match sorting assets created after this date. (yyyy-MM-dd format)                | | creationDateEnd                | Match sorting assets created before this date. (yyyy-MM-dd format)               | | lastModificationDateStart      | Match sorting assets modified after this date. (yyyy-MM-dd format)               | | lastModificationDateEnd        | Match sorting assets modified before this date. (yyyy-MM-dd format)              | Note: For following special characters in strings (applicable for queueNames, externalIds, sortSubflows, metadata) use:  : &rarr; /colon/  ; &rarr; /semi/  \\ &rarr; /bsol/  Example - filter=queueNames:SortPrep&count=10&offset=0",
        tags = { "sort-data-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Success", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/sortdata/{domain}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> listSortingAssets(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @NotNull @Parameter(name = "filterRequest", description = "Use the optional filter parameter to decide which sorting assets should be listed (ALL of them if no filter specified)", required = true, in = ParameterIn.QUERY) @Valid SortingDataFilterRequest filterRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/secrets/{domain}/migrateVault : Migrate secrets to vault.
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "migrateVault",
        summary = "Migrate secrets to vault.",
        tags = { "secret-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Boolean.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/secrets/{domain}/migrateVault",
        produces = { "*/*" }
    )
    
    default ResponseEntity<Boolean> migrateVault(
        
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/flow-models/{domain}/{flowModelId}/publish : Publish flow model
     * Publish specified flow model version to orchestration runtime environment. &lt;br /&gt;&lt;b&gt;Version 20.4.0:&lt;/b&gt; Flow model &#39;&lt;i&gt;version&lt;/i&gt;&#39; property changed from datatype string to integer in response body.
     *
     * @param domain Domain id (required)
     * @param flowModelId Flow model id (required)
     * @param version Specify version (optional). If omitted, latest version will be published. (optional)
     * @return Flow model published successfully (status code 200)
     *         or Bad request (status code 400)
     *         or Flow model not found (status code 404)
     */
    @Operation(
        operationId = "publish",
        summary = "Publish flow model",
        description = "Publish specified flow model version to orchestration runtime environment. <br /><b>Version 20.4.0:</b> Flow model '<i>version</i>' property changed from datatype string to integer in response body.",
        tags = { "flow-model-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Flow model published successfully", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseTenantFlowmodel.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Flow model not found", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/flow-models/{domain}/{flowModelId}/publish",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseTenantFlowmodel> publish(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "flowModelId", description = "Flow model id", required = true, in = ParameterIn.PATH) @PathVariable("flowModelId") UUID flowModelId,
        @Parameter(name = "version", description = "Specify version (optional). If omitted, latest version will be published.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"sdpermissions\" : [ \"sdpermissions\", \"sdpermissions\" ], \"nodes\" : [ { \"internal\" : true, \"metadata\" : [ { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" }, { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" } ], \"instanceId\" : \"instanceId\", \"subtype\" : \"directory_channel\", \"displayName\" : \"displayName\", \"x\" : 1, \"y\" : 5, \"attributes\" : [ { \"name\" : \"name\", \"value\" : \"value\" }, { \"name\" : \"name\", \"value\" : \"value\" } ], \"id\" : \"id\", \"type\" : \"input\", \"connections\" : [ { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" }, { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" } ] }, { \"internal\" : true, \"metadata\" : [ { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" }, { \"name\" : \"name\", \"text\" : \"text\", \"type\" : \"type\" } ], \"instanceId\" : \"instanceId\", \"subtype\" : \"directory_channel\", \"displayName\" : \"displayName\", \"x\" : 1, \"y\" : 5, \"attributes\" : [ { \"name\" : \"name\", \"value\" : \"value\" }, { \"name\" : \"name\", \"value\" : \"value\" } ], \"id\" : \"id\", \"type\" : \"input\", \"connections\" : [ { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" }, { \"condition\" : { \"datatype\" : \"string\", \"values\" : [ \"values\", \"values\" ], \"name\" : \"name\", \"type\" : \"outcome\", \"value\" : \"value\", \"operator\" : \"EQ\" }, \"sourceAnchor\" : \"sourceAnchor\", \"targetAnchor\" : \"targetAnchor\", \"displayName\" : \"displayName\", \"defaultConnection\" : true, \"targetNodeId\" : \"targetNodeId\", \"targetNode\" : \"targetNode\" } ] } ], \"lockedBy\" : \"lockedBy\", \"latestVersion\" : true, \"stateComment\" : \"stateComment\", \"name\" : \"name\", \"description\" : \"description\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"state\" : \"DRAFT\", \"type\" : \"COMMUNICATION\", \"version\" : 6, \"revision\" : 0 }, \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/flow-model-contexts/{domain}/{flowModelContextId}/publish : Publish flow context
     * Publish specified flow context version to orchestration runtime environment.
     *
     * @param domain Domain id (required)
     * @param flowModelContextId Flow context id (required)
     * @param version Specify version (optional). If omitted, latest version will be published. (optional)
     * @return Flow model context published successfully. (status code 200)
     *         or Bad request (status code 400)
     *         or Flow model context not found. (status code 404)
     */
    @Operation(
        operationId = "publish1",
        summary = "Publish flow context",
        description = "Publish specified flow context version to orchestration runtime environment.",
        tags = { "flow-model-context-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Flow model context published successfully.", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseFlowModelContextSnapshot.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Flow model context not found.", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/flow-model-contexts/{domain}/{flowModelContextId}/publish",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseFlowModelContextSnapshot> publish1(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "flowModelContextId", description = "Flow context id", required = true, in = ParameterIn.PATH) @PathVariable("flowModelContextId") UUID flowModelContextId,
        @Parameter(name = "version", description = "Specify version (optional). If omitted, latest version will be published.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"snapshotId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"name\" : \"name\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"xmlContent\" : \"xmlContent\", \"version\" : 0, \"domainId\" : \"domainId\", \"content\" : \"content\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/cron-jobs/{domain}/{cronJobId} : Gets a cron job
     *
     * @param domain Domain id (required)
     * @param cronJobId CronJobId (required)
     * @return default response (status code 200)
     */
    @Operation(
        operationId = "readSchedule",
        summary = "Gets a cron job",
        tags = { "cron-jobs-controller" },
        responses = {
            @ApiResponse(responseCode = "default", description = "default response", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseCronJob.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/cron-jobs/{domain}/{cronJobId}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseCronJob> readSchedule(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "cronJobId", description = "CronJobId", required = true, in = ParameterIn.PATH) @PathVariable("cronJobId") UUID cronJobId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"dryRun\" : true, \"jobAvailable\" : true, \"endDateStart\" : \"endDateStart\", \"startDateEnd\" : \"startDateEnd\", \"enabled\" : true, \"mode\" : \"BATCH\", \"cronType\" : \"markDeleted\", \"sortingAssetStatuses\" : [ \"processed\", \"processed\" ], \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"appConsolidation\" : true, \"headers\" : { \"key\" : \"headers\" }, \"endDateEnd\" : \"endDateEnd\", \"serviceName\" : \"serviceName\", \"domainId\" : \"domainId\", \"communicationIdList\" : [ \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" ], \"cronExpression\" : \"cronExpression\", \"startDateStart\" : \"startDateStart\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"cacheTimeout\" : 0.8008282, \"inputPath\" : \"inputPath\", \"preSortQueueName\" : \"preSortQueueName\", \"name\" : \"name\", \"statuses\" : [ \"canceled\", \"canceled\" ], \"channelName\" : \"channelName\", \"postSortQueueName\" : \"postSortQueueName\" }, \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/flow-instances/{id}/release : Continue a held flow instance
     * Release a flow instance in holding state.
     *
     * @param domain Domain id (required)
     * @param id Flow instance id (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "releaseHoldingFlowInstances",
        summary = "Continue a held flow instance",
        description = "Release a flow instance in holding state.",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/flow-instances/{id}/release",
        produces = { "*/*" }
    )
    
    default ResponseEntity<String> releaseHoldingFlowInstances(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Flow instance id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/flow-steps/{id}/release : Continue a held flow step
     * Release a flow step in holding state.
     *
     * @param domain Domain id (required)
     * @param id Flow step id (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "releaseHoldingFlowStep",
        summary = "Continue a held flow step",
        description = "Release a flow step in holding state.",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/release",
        produces = { "*/*" }
    )
    
    default ResponseEntity<String> releaseHoldingFlowStep(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Flow step id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/jobs/{id}/reprocessing : Reprocess job
     * Reprocess the job with the specified id, optionally using the current flow model and/or the current flow context
     *
     * @param domain Domain id (required)
     * @param id Job id (required)
     * @param useCurrentFlowModel Use current flow model (instead of the one stored in the job) (optional, default to false)
     * @param useCurrentFlowContext Use current flow context (instead of the one stored in the job (optional, default to false)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "reprocessJob",
        summary = "Reprocess job",
        description = "Reprocess the job with the specified id, optionally using the current flow model and/or the current flow context",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/jobs/{id}/reprocessing",
        produces = { "*/*" }
    )
    
    default ResponseEntity<String> reprocessJob(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Job id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "useCurrentFlowModel", description = "Use current flow model (instead of the one stored in the job)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useCurrentFlowModel", required = false, defaultValue = "false") Boolean useCurrentFlowModel,
        @Parameter(name = "useCurrentFlowContext", description = "Use current flow context (instead of the one stored in the job", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useCurrentFlowContext", required = false, defaultValue = "false") Boolean useCurrentFlowContext
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/secrets/{domain}/rollover
     *
     * @param oldKeyId  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "rolloverKeys",
        tags = { "secret-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Integer.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/secrets/{domain}/rollover",
        produces = { "*/*" }
    )
    
    default ResponseEntity<Integer> rolloverKeys(
        @NotNull @Parameter(name = "oldKeyId", description = "", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "oldKeyId", required = true) String oldKeyId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/secrets/{domain}/{secretId}/exists
     *
     * @param domain  (required)
     * @param secretId  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "secretExists",
        tags = { "secret-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseBoolean.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/secrets/{domain}/{secretId}/exists",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseBoolean> secretExists(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "secretId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("secretId") UUID secretId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : true, \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/secrets/{domain}/{secretId}
     *
     * @param domain  (required)
     * @param secretId  (required)
     * @param secretInfo  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "setSecret",
        tags = { "secret-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/secrets/{domain}/{secretId}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<String> setSecret(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "secretId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("secretId") UUID secretId,
        @Parameter(name = "SecretInfo", description = "", required = true) @Valid @RequestBody SecretInfo secretInfo
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/jobs/post-sort : Trigger post-sort run
     * Trigger a post-sort related job
     *
     * @param domain Domain id (required)
     * @param postSortRunOption    | Run setting            | description                                                                                           | |------------------------|-------------------------------------------------------------------------------------------------------| | flowModelId            | Select sorting assets matching flow model id.                                                         | | appConsolidation       | Consolidate multiple communications.                                                                  | | dryRun                 | Dry run                                                                                               | | externalId             | Set externalID on the job for this post-sort run.                                                     | | customerList           | Select individual list of customer numbers or ranges of numbers to be processed in post-sort run.     | | postSortQueueName      | Set post-sort queue to use in this post-sort run. If not specified, all post-sort queues will be included in the run.|   | Sort asset filter name |Filter value description                                                                               | |------------------------|-------------------------------------------------------------------------------------------------------| | ids                    | Filter sorting assets matching sorting index ids.                                                     | | jobIds                 | Filter sorting assets matching job ids.                                                               | | flowStepIds            | Filter sorting assets matching flow step ids.                                                         | | communicationIds       | Filter sorting assets matching communication ids.                                                     | | queueNames             | Filter sorting assets matching pre-sort queue name                                                     (Note: Only first entry of list is currently supported for post-sort run).       | | externalIds            | Filter sorting assets matching external ids.                                                          | | creationDateStart      | Filter sorting assets created after this date (yyyy-MM-dd format or elapsed period in negative days). | | creationDateEnd        | Filter sorting assets created before this date (yyyy-MM-dd format or elapsed period in negative days).| (required)
     * @return Post sort run(s) triggered. (status code 201)
     *         or Bad request. Validation failure. (status code 400)
     *         or Domain not found or flow model not found in domain. (status code 404)
     */
    @Operation(
        operationId = "startPostSortJob",
        summary = "Trigger post-sort run",
        description = "Trigger a post-sort related job",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "201", description = "Post sort run(s) triggered.", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request. Validation failure.", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Domain not found or flow model not found in domain.", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/jobs/post-sort",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<GenericResponse> startPostSortJob(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "PostSortRunOption", description = "   | Run setting            | description                                                                                           | |------------------------|-------------------------------------------------------------------------------------------------------| | flowModelId            | Select sorting assets matching flow model id.                                                         | | appConsolidation       | Consolidate multiple communications.                                                                  | | dryRun                 | Dry run                                                                                               | | externalId             | Set externalID on the job for this post-sort run.                                                     | | customerList           | Select individual list of customer numbers or ranges of numbers to be processed in post-sort run.     | | postSortQueueName      | Set post-sort queue to use in this post-sort run. If not specified, all post-sort queues will be included in the run.|   | Sort asset filter name |Filter value description                                                                               | |------------------------|-------------------------------------------------------------------------------------------------------| | ids                    | Filter sorting assets matching sorting index ids.                                                     | | jobIds                 | Filter sorting assets matching job ids.                                                               | | flowStepIds            | Filter sorting assets matching flow step ids.                                                         | | communicationIds       | Filter sorting assets matching communication ids.                                                     | | queueNames             | Filter sorting assets matching pre-sort queue name                                                     (Note: Only first entry of list is currently supported for post-sort run).       | | externalIds            | Filter sorting assets matching external ids.                                                          | | creationDateStart      | Filter sorting assets created after this date (yyyy-MM-dd format or elapsed period in negative days). | | creationDateEnd        | Filter sorting assets created before this date (yyyy-MM-dd format or elapsed period in negative days).|", required = true) @Valid @RequestBody PostSortRunOption postSortRunOption
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/flow-instances/{id}/stop : Cancel flow instance
     * Stop a running flow instance entry (including all flow steps) in runtime database.
     *
     * @param domain Domain id (required)
     * @param id Flow instance id (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "stopFlowInstance",
        summary = "Cancel flow instance",
        description = "Stop a running flow instance entry (including all flow steps) in runtime database.",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/flow-instances/{id}/stop",
        produces = { "*/*" }
    )
    
    default ResponseEntity<String> stopFlowInstance(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Flow instance id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/flow-steps/{id}/stop : Cancel flow step
     * Stop a running flow step in runtime database.
     *
     * @param domain Domain id (required)
     * @param id Flow step id (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "stopFlowStep",
        summary = "Cancel flow step",
        description = "Stop a running flow step in runtime database.",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/flow-steps/{id}/stop",
        produces = { "*/*" }
    )
    
    default ResponseEntity<String> stopFlowStep(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Flow step id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/{domain}/jobs/{id}/stop : Cancel job
     * Stop a running job entry (including all flow instances) in runtime database.
     *
     * @param domain Domain id (required)
     * @param id Job id (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "stopJob",
        summary = "Cancel job",
        description = "Stop a running job entry (including all flow instances) in runtime database.",
        tags = { "runtime-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/{domain}/jobs/{id}/stop",
        produces = { "*/*" }
    )
    
    default ResponseEntity<String> stopJob(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Job id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/cron-jobs/{domain}/{cronJobId}/trigger : Trigger a cron job
     *
     * @param domain Domain id (required)
     * @param cronJobId CronJobId (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "triggerSchedule",
        summary = "Trigger a cron job",
        tags = { "cron-jobs-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/cron-jobs/{domain}/{cronJobId}/trigger",
        produces = { "*/*" }
    )
    
    default ResponseEntity<String> triggerSchedule(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "cronJobId", description = "CronJobId", required = true, in = ParameterIn.PATH) @PathVariable("cronJobId") UUID cronJobId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/flow-models/{domain}/{flowModelId}/unpublish : Unpublish flow model
     * Unpublish specified flow model version from orchestration runtime environment. 
     *
     * @param domain Domain id (required)
     * @param flowModelId Flow model id (required)
     * @param version Specify version (optional). If omitted, latest version will be unpublished. (optional)
     * @return Flow model published successfully (status code 200)
     *         or Bad request (status code 400)
     *         or Flow model not found (status code 404)
     */
    @Operation(
        operationId = "unpublish",
        summary = "Unpublish flow model",
        description = "Unpublish specified flow model version from orchestration runtime environment. ",
        tags = { "flow-model-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Flow model published successfully", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Flow model not found", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/flow-models/{domain}/{flowModelId}/unpublish",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> unpublish(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "flowModelId", description = "Flow model id", required = true, in = ParameterIn.PATH) @PathVariable("flowModelId") UUID flowModelId,
        @Parameter(name = "version", description = "Specify version (optional). If omitted, latest version will be unpublished.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/flow-models/{domain}/unpublish : Unpublish list of flow models
     * Unpublish specified flow models version from orchestration runtime environment. 
     *
     * @param domain Domain id (required)
     * @param flowObjectsRequest  (required)
     * @return OK (status code 200)
     *         or Bad request (status code 400)
     */
    @Operation(
        operationId = "unpublish1",
        summary = "Unpublish list of flow models",
        description = "Unpublish specified flow models version from orchestration runtime environment. ",
        tags = { "flow-model-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/flow-models/{domain}/unpublish",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<GenericResponse> unpublish1(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "FlowObjectsRequest", description = "", required = true) @Valid @RequestBody FlowObjectsRequest flowObjectsRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/flow-model-contexts/{domain}/{flowModelContextId}/unpublish : Unpublish flow context
     * Unpublish specified flow context version from orchestration runtime environment. 
     *
     * @param domain Domain id (required)
     * @param flowModelContextId Flow context id (required)
     * @param version Specify version (optional). If omitted, latest version will be unpublished. (optional)
     * @return Flow model context unpublished successfully (status code 200)
     *         or Bad request (status code 400)
     *         or Flow model context not found (status code 404)
     */
    @Operation(
        operationId = "unpublish2",
        summary = "Unpublish flow context",
        description = "Unpublish specified flow context version from orchestration runtime environment. ",
        tags = { "flow-model-context-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Flow model context unpublished successfully", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Flow model context not found", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/flow-model-contexts/{domain}/{flowModelContextId}/unpublish",
        produces = { "application/json" }
    )
    
    default ResponseEntity<GenericResponse> unpublish2(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "flowModelContextId", description = "Flow context id", required = true, in = ParameterIn.PATH) @PathVariable("flowModelContextId") UUID flowModelContextId,
        @Parameter(name = "version", description = "Specify version (optional). If omitted, latest version will be unpublished.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/flow-model-contexts/{domain}/unpublish : Unpublish list of flow contexts
     * Unpublish specified flow contexts from orchestration runtime environment. 
     *
     * @param domain Domain id (required)
     * @param flowObjectsRequest  (required)
     * @return OK (status code 200)
     *         or Bad request (status code 400)
     */
    @Operation(
        operationId = "unpublish3",
        summary = "Unpublish list of flow contexts",
        description = "Unpublish specified flow contexts from orchestration runtime environment. ",
        tags = { "flow-model-context-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/flow-model-contexts/{domain}/unpublish",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<GenericResponse> unpublish3(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "FlowObjectsRequest", description = "", required = true) @Valid @RequestBody FlowObjectsRequest flowObjectsRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/runtime/cache/update : Updates input file cache
     * Checks if files in the cache should be updated.
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "updateCache",
        summary = "Updates input file cache",
        description = "Checks if files in the cache should be updated.",
        tags = { "cache-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/runtime/cache/update",
        produces = { "application/json" }
    )
    
    default ResponseEntity<String> updateCache(
        
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/configuration/{domainId}
     *
     * @param domainId  (required)
     * @param modelConfiguration  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "updateConfiguration",
        tags = { "configuration-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseConfiguration.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/configuration/{domainId}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseConfiguration> updateConfiguration(
        @Size(min = 1, max = 255) @Parameter(name = "domainId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("domainId") String domainId,
        @Parameter(name = "ModelConfiguration", description = "", required = true) @Valid @RequestBody ModelConfiguration modelConfiguration
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"configName\" : \"configName\", \"configDetails\" : { \"key\" : { \"values\" : [ { }, { } ], \"secretId\" : \"secretId\", \"value\" : \"value\" } }, \"active\" : true, \"configType\" : \"configType\", \"domainId\" : \"domainId\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/cron-jobs/{domain}/{cronJobId} : Updates a cron job
     *
     * @param domain Domain id (required)
     * @param cronJobId CronJobId (required)
     * @param cronJob Cron job. It can apply to jobs or sort assets.&lt;br/&gt;name: Name of the cron job&lt;br/&gt;cronExpression: Cron expression in UNIX format that reflects when the cron job should be executed (the main cron orchestration cleanup job is executed hourly by default)&lt;br/&gt;cronType: Cron job type. Available values: markDeleted,wipe,startJob,updateExpirationTime,wipeSortingAssets,expireSortingAssets,sortingAndBundling. When wipe is selected the filter parameters are not used.&lt;br/&gt;startDateStart: Filter jobs matching started date after this date or sort assets created after this date. Date is a (yyyy-MM-dd format) String. It&#39;s also possible to use a negative number, representing the number of days before today.&lt;br/&gt;startDateEnd: Filter jobs matching started date before this date or sort assets created before this date. Date is a (yyyy-MM-dd format) String. It&#39;s also possible to use a negative number, representing the number of days before today.&lt;br/&gt;endDateStart: Filter jobs matching ended date after this date or sort assets modified after this date. Date is a (yyyy-MM-dd format) String. It&#39;s also possible to use a negative number, representing the number of days before today&lt;br/&gt;endDateEnd: Filter jobs matching ended date before this date or sort assets modified before this date. Date is a (yyyy-MM-dd format) String. It&#39;s also possible to use a negative number, representing the number of days before today&lt;br/&gt;statuses: Match jobs with any of these statuses. Possible values for jobs: complete,error,canceled,deleted&lt;br/&gt;sortingAssetStatuses: Match sorting assets with any of these statuses, possible values for sort assets: processed,waiting,expired,canceled&lt;br/&gt;serviceName: service to trigger for job&lt;br/&gt;channelName: input channel for pulling data&lt;br/&gt;inputPath: path parameter for the input channel&lt;br/&gt;headers: map of headers for starting job&lt;br/&gt;cacheTimeout: optional duration of file cache&lt;br/&gt;mode: Filter jobs matching this mode (ONDEMAND|BATCH)&lt;br/&gt;flowModelId: Filter sorting assets matching flow model id&lt;br/&gt;communicationIdList: Filter sorting assets matching the communication id (only one) or when running sorting&amp;bundling with appConsolidation equal to true, use the specified communications,&lt;br/&gt;when appConsolidation is false, only one communication id should be present&lt;br/&gt;preSortQueueName: Filter sorting assets matching pre sort queue name&lt;br/&gt;jobId: Filter sorting assets matching jobId&lt;br/&gt;postSortQueueName: queue name used in the post sort queue name&lt;br/&gt;appConsolidation: says whether multiple communications should be consolidated when running sorting&amp;bundling&lt;br/&gt;enabled: Determines whether the cron job should be triggered or not. Default value: true (required)
     * @return default response (status code 200)
     */
    @Operation(
        operationId = "updateSchedule",
        summary = "Updates a cron job",
        tags = { "cron-jobs-controller" },
        responses = {
            @ApiResponse(responseCode = "default", description = "default response", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseCronJob.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/cron-jobs/{domain}/{cronJobId}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseCronJob> updateSchedule(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "cronJobId", description = "CronJobId", required = true, in = ParameterIn.PATH) @PathVariable("cronJobId") UUID cronJobId,
        @Parameter(name = "CronJob", description = "Cron job. It can apply to jobs or sort assets.<br/>name: Name of the cron job<br/>cronExpression: Cron expression in UNIX format that reflects when the cron job should be executed (the main cron orchestration cleanup job is executed hourly by default)<br/>cronType: Cron job type. Available values: markDeleted,wipe,startJob,updateExpirationTime,wipeSortingAssets,expireSortingAssets,sortingAndBundling. When wipe is selected the filter parameters are not used.<br/>startDateStart: Filter jobs matching started date after this date or sort assets created after this date. Date is a (yyyy-MM-dd format) String. It's also possible to use a negative number, representing the number of days before today.<br/>startDateEnd: Filter jobs matching started date before this date or sort assets created before this date. Date is a (yyyy-MM-dd format) String. It's also possible to use a negative number, representing the number of days before today.<br/>endDateStart: Filter jobs matching ended date after this date or sort assets modified after this date. Date is a (yyyy-MM-dd format) String. It's also possible to use a negative number, representing the number of days before today<br/>endDateEnd: Filter jobs matching ended date before this date or sort assets modified before this date. Date is a (yyyy-MM-dd format) String. It's also possible to use a negative number, representing the number of days before today<br/>statuses: Match jobs with any of these statuses. Possible values for jobs: complete,error,canceled,deleted<br/>sortingAssetStatuses: Match sorting assets with any of these statuses, possible values for sort assets: processed,waiting,expired,canceled<br/>serviceName: service to trigger for job<br/>channelName: input channel for pulling data<br/>inputPath: path parameter for the input channel<br/>headers: map of headers for starting job<br/>cacheTimeout: optional duration of file cache<br/>mode: Filter jobs matching this mode (ONDEMAND|BATCH)<br/>flowModelId: Filter sorting assets matching flow model id<br/>communicationIdList: Filter sorting assets matching the communication id (only one) or when running sorting&bundling with appConsolidation equal to true, use the specified communications,<br/>when appConsolidation is false, only one communication id should be present<br/>preSortQueueName: Filter sorting assets matching pre sort queue name<br/>jobId: Filter sorting assets matching jobId<br/>postSortQueueName: queue name used in the post sort queue name<br/>appConsolidation: says whether multiple communications should be consolidated when running sorting&bundling<br/>enabled: Determines whether the cron job should be triggered or not. Default value: true", required = true) @Valid @RequestBody CronJob cronJob
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"dryRun\" : true, \"jobAvailable\" : true, \"endDateStart\" : \"endDateStart\", \"startDateEnd\" : \"startDateEnd\", \"enabled\" : true, \"mode\" : \"BATCH\", \"cronType\" : \"markDeleted\", \"sortingAssetStatuses\" : [ \"processed\", \"processed\" ], \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"appConsolidation\" : true, \"headers\" : { \"key\" : \"headers\" }, \"endDateEnd\" : \"endDateEnd\", \"serviceName\" : \"serviceName\", \"domainId\" : \"domainId\", \"communicationIdList\" : [ \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" ], \"cronExpression\" : \"cronExpression\", \"startDateStart\" : \"startDateStart\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"cacheTimeout\" : 0.8008282, \"inputPath\" : \"inputPath\", \"preSortQueueName\" : \"preSortQueueName\", \"name\" : \"name\", \"statuses\" : [ \"canceled\", \"canceled\" ], \"channelName\" : \"channelName\", \"postSortQueueName\" : \"postSortQueueName\" }, \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/sortdata/{domain} : Update state for all sort assets matching filter criteria. Possible parameters are domain (in the URL), state and the mandatory filter
     * Sorting assets using synchronous mode is not included.  The filter value is a semicolon delimited list of key value pairs.  List values separate possible values with commas. These are the only keys possible, please ignore the parameters below this list: | Filter name                    | Filter value description                                                         | |--------------------------------|----------------------------------------------------------------------------------| | flowModelIds                   | Match sorting assets with these flow model ids.                                  | | communicationIds               | Match sorting assets with these communication ids.                               | | queueNames                     | Match sorting assets with these queue names.                                     | | externalIds                    | Match sorting assets with these external ids.                                    | | flowStepIds                    | Match sorting assets with these flow step ids.                                   | | ids                            | Match sorting assets with these sorting asset ids.                               | | jobIds                         | Match sorting assets with these job ids.                                         | | referenceIds                   | Match sorting assets with these reference ids.                                   | | sortSubflows                   | Match sorting assets with these sort sub flows.                                  | | metadata                       | Match sorting assets with these metadata values.                                 | | states                         | Match sorting assets with any of these states. Possible values: processed,waiting,expired,canceled,all| | customersCountFrom             | Match sorting assets having customer count from this number.                     | | customersCountTo               | Match sorting assets having customer count to this number.                       | | creationDateStart              | Match sorting assets created after this date. (yyyy-MM-dd format)                | | creationDateEnd                | Match sorting assets created before this date. (yyyy-MM-dd format)               | | lastModificationDateStart      | Match sorting assets modified after this date. (yyyy-MM-dd format)               | | lastModificationDateEnd        | Match sorting assets modified before this date. (yyyy-MM-dd format)              | Note: For following special characters in strings (applicable for queueNames, externalIds, sortSubflows, metadata) use:  : &amp;rarr; /colon/  ; &amp;rarr; /semi/  \\ &amp;rarr; /bsol/  Example - state&#x3D;waiting&amp;filter&#x3D;externalIds:Ext001;states:processed
     *
     * @param domain Domain id (required)
     * @param updateStateRequest  (optional)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "updateState",
        summary = "Update state for all sort assets matching filter criteria. Possible parameters are domain (in the URL), state and the mandatory filter",
        description = "Sorting assets using synchronous mode is not included.  The filter value is a semicolon delimited list of key value pairs.  List values separate possible values with commas. These are the only keys possible, please ignore the parameters below this list: | Filter name                    | Filter value description                                                         | |--------------------------------|----------------------------------------------------------------------------------| | flowModelIds                   | Match sorting assets with these flow model ids.                                  | | communicationIds               | Match sorting assets with these communication ids.                               | | queueNames                     | Match sorting assets with these queue names.                                     | | externalIds                    | Match sorting assets with these external ids.                                    | | flowStepIds                    | Match sorting assets with these flow step ids.                                   | | ids                            | Match sorting assets with these sorting asset ids.                               | | jobIds                         | Match sorting assets with these job ids.                                         | | referenceIds                   | Match sorting assets with these reference ids.                                   | | sortSubflows                   | Match sorting assets with these sort sub flows.                                  | | metadata                       | Match sorting assets with these metadata values.                                 | | states                         | Match sorting assets with any of these states. Possible values: processed,waiting,expired,canceled,all| | customersCountFrom             | Match sorting assets having customer count from this number.                     | | customersCountTo               | Match sorting assets having customer count to this number.                       | | creationDateStart              | Match sorting assets created after this date. (yyyy-MM-dd format)                | | creationDateEnd                | Match sorting assets created before this date. (yyyy-MM-dd format)               | | lastModificationDateStart      | Match sorting assets modified after this date. (yyyy-MM-dd format)               | | lastModificationDateEnd        | Match sorting assets modified before this date. (yyyy-MM-dd format)              | Note: For following special characters in strings (applicable for queueNames, externalIds, sortSubflows, metadata) use:  : &rarr; /colon/  ; &rarr; /semi/  \\ &rarr; /bsol/  Example - state=waiting&filter=externalIds:Ext001;states:processed",
        tags = { "sort-data-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/sortdata/{domain}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<GenericResponse> updateState(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "UpdateStateRequest", description = "") @Valid @RequestBody(required = false) UpdateStateRequest updateStateRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/sortdata/{domain}/{id} : Update state for all sort assets referenced by given id. Possible parameters are domain (in the URL), id (in the URL) and state.
     * Sorting assets using synchronous mode is not included.  Example - state&#x3D;expired
     *
     * @param domain Domain id (required)
     * @param id Id (required)
     * @param updateState1Request  (optional)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "updateState1",
        summary = "Update state for all sort assets referenced by given id. Possible parameters are domain (in the URL), id (in the URL) and state.",
        description = "Sorting assets using synchronous mode is not included.  Example - state=expired",
        tags = { "sort-data-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseSortingAsset.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/sortdata/{domain}/{id}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseSortingAsset> updateState1(
        @Size(min = 1, max = 255) @Parameter(name = "domain", description = "Domain id", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "Id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "UpdateState1Request", description = "") @Valid @RequestBody(required = false) UpdateState1Request updateState1Request
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"data\" : { \"metadata\" : \"metadata\", \"communicationId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"sortSubflow\" : \"sortSubflow\", \"externalId\" : \"externalId\", \"subpackageIds\" : \"subpackageIds\", \"flowStepId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"creationDate\" : \"2000-01-23T04:56:07.000+00:00\", \"referenceId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"jobId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"lastModificationDate\" : \"2000-01-23T04:56:07.000+00:00\", \"queueName\" : \"queueName\", \"customersCount\" : 0, \"subPackageIds\" : \"subPackageIds\", \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"flowModelId\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"state\" : \"processed\", \"engineInfo\" : \"engineInfo\" }, \"details\" : \"details\", \"message\" : \"message\", \"status\" : \"success|failure\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/tenants/updateTenant
     *
     * @param createTenantBody  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "updateTenant",
        tags = { "tenant-admin-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataResponseTenant.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/tenants/updateTenant",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseTenant> updateTenant(
        @Parameter(name = "CreateTenantBody", description = "", required = true) @Valid @RequestBody CreateTenantBody createTenantBody
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/tenants/{tenantId}/schema
     *
     * @param tenantId  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "updateTenantSchema",
        tags = { "tenant-admin-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DataResponseTenant.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/tenants/{tenantId}/schema",
        produces = { "application/json" }
    )
    
    default ResponseEntity<DataResponseTenant> updateTenantSchema(
        @Parameter(name = "tenantId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("tenantId") String tenantId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" }, \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/tenants/all/schema
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "updateTenantSchemas",
        tags = { "tenant-admin-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ListResponseTenant.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/tenants/all/schema",
        produces = { "application/json" }
    )
    
    default ResponseEntity<ListResponseTenant> updateTenantSchemas(
        
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"data\" : [ { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" }, { \"schema\" : { \"schemaMissingFromDatabase\" : true, \"schemaId\" : \"schemaId\", \"latestSchemaChangeLogEntry\" : { \"liquiBaseVersion\" : \"liquiBaseVersion\", \"orderExecuted\" : 0, \"id\" : \"id\", \"dateExecuted\" : \"2000-01-23T04:56:07.000+00:00\" } }, \"tenantId\" : \"tenantId\" } ], \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
