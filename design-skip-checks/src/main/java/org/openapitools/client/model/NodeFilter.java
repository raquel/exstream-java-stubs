/*
 * Exstream Design
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * NodeFilter
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-03-17T13:54:16.859257228Z[Europe/Lisbon]")
public class NodeFilter {
  public static final String SERIALIZED_NAME_IDS = "ids";
  @SerializedName(SERIALIZED_NAME_IDS)
  private List<UUID> ids;

  /**
   * Gets or Sets types
   */
  @JsonAdapter(TypesEnum.Adapter.class)
  public enum TypesEnum {
    INPUT("input"),
    
    OUTPUT("output"),
    
    OUTPUT_EXTERNAL_RESPONSE("output_external_response"),
    
    COMMUNICATION("communication"),
    
    COMMUNICATION_RESPONSE("communication_response"),
    
    EXTERNALSUBFLOW("externalsubflow"),
    
    DECIDER("decider"),
    
    DELAY("delay"),
    
    PROCESSOR("processor"),
    
    AGGREGATION("aggregation"),
    
    EVENT("event");

    private String value;

    TypesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypesEnum fromValue(String value) {
      for (TypesEnum b : TypesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPES = "types";
  @SerializedName(SERIALIZED_NAME_TYPES)
  private List<TypesEnum> types;

  /**
   * Gets or Sets excludedTypes
   */
  @JsonAdapter(ExcludedTypesEnum.Adapter.class)
  public enum ExcludedTypesEnum {
    INPUT("input"),
    
    OUTPUT("output"),
    
    OUTPUT_EXTERNAL_RESPONSE("output_external_response"),
    
    COMMUNICATION("communication"),
    
    COMMUNICATION_RESPONSE("communication_response"),
    
    EXTERNALSUBFLOW("externalsubflow"),
    
    DECIDER("decider"),
    
    DELAY("delay"),
    
    PROCESSOR("processor"),
    
    AGGREGATION("aggregation"),
    
    EVENT("event");

    private String value;

    ExcludedTypesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ExcludedTypesEnum fromValue(String value) {
      for (ExcludedTypesEnum b : ExcludedTypesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ExcludedTypesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ExcludedTypesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ExcludedTypesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ExcludedTypesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ExcludedTypesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EXCLUDED_TYPES = "excludedTypes";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_TYPES)
  private List<ExcludedTypesEnum> excludedTypes;

  /**
   * Gets or Sets subtypes
   */
  @JsonAdapter(SubtypesEnum.Adapter.class)
  public enum SubtypesEnum {
    DIRECTORY_CHANNEL("directory_channel"),
    
    HTTPS_CHANNEL("https_channel"),
    
    AWS_S3_INPUT_CHANNEL("aws_s3_input_channel"),
    
    EMPOWER_FULFILLMENT_CHANNEL("empower_fulfillment_channel"),
    
    POST_SORT_EVENT_CHANNEL("post_sort_event_channel"),
    
    FILE_CHANNEL("file_channel"),
    
    EMAIL_CHANNEL("email_channel"),
    
    DOCUMENTRESPONSE_CHANNEL("documentresponse_channel"),
    
    AZURE_BLOB_CHANNEL("azure_blob_channel"),
    
    AWS_S3_CHANNEL("aws_s3_channel"),
    
    GCP_CS_OUT_CHANNEL("gcp_cs_out_channel"),
    
    GENERIC("generic"),
    
    GENERIC_CHANNEL("generic_channel"),
    
    UNKNOWN("unknown");

    private String value;

    SubtypesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SubtypesEnum fromValue(String value) {
      for (SubtypesEnum b : SubtypesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SubtypesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SubtypesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SubtypesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SubtypesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SubtypesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SUBTYPES = "subtypes";
  @SerializedName(SERIALIZED_NAME_SUBTYPES)
  private List<SubtypesEnum> subtypes;

  /**
   * Gets or Sets excludedSubtypes
   */
  @JsonAdapter(ExcludedSubtypesEnum.Adapter.class)
  public enum ExcludedSubtypesEnum {
    DIRECTORY_CHANNEL("directory_channel"),
    
    HTTPS_CHANNEL("https_channel"),
    
    AWS_S3_INPUT_CHANNEL("aws_s3_input_channel"),
    
    EMPOWER_FULFILLMENT_CHANNEL("empower_fulfillment_channel"),
    
    POST_SORT_EVENT_CHANNEL("post_sort_event_channel"),
    
    FILE_CHANNEL("file_channel"),
    
    EMAIL_CHANNEL("email_channel"),
    
    DOCUMENTRESPONSE_CHANNEL("documentresponse_channel"),
    
    AZURE_BLOB_CHANNEL("azure_blob_channel"),
    
    AWS_S3_CHANNEL("aws_s3_channel"),
    
    GCP_CS_OUT_CHANNEL("gcp_cs_out_channel"),
    
    GENERIC("generic"),
    
    GENERIC_CHANNEL("generic_channel"),
    
    UNKNOWN("unknown");

    private String value;

    ExcludedSubtypesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ExcludedSubtypesEnum fromValue(String value) {
      for (ExcludedSubtypesEnum b : ExcludedSubtypesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ExcludedSubtypesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ExcludedSubtypesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ExcludedSubtypesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ExcludedSubtypesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ExcludedSubtypesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EXCLUDED_SUBTYPES = "excludedSubtypes";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_SUBTYPES)
  private List<ExcludedSubtypesEnum> excludedSubtypes;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_CASE_SENSITIVE = "caseSensitive";
  @SerializedName(SERIALIZED_NAME_CASE_SENSITIVE)
  private Boolean caseSensitive;

  public static final String SERIALIZED_NAME_WHOLE_WORD = "wholeWord";
  @SerializedName(SERIALIZED_NAME_WHOLE_WORD)
  private Boolean wholeWord;

  /**
   * Gets or Sets subTypes
   */
  @JsonAdapter(SubTypesEnum.Adapter.class)
  public enum SubTypesEnum {
    DIRECTORY_CHANNEL("directory_channel"),
    
    HTTPS_CHANNEL("https_channel"),
    
    AWS_S3_INPUT_CHANNEL("aws_s3_input_channel"),
    
    EMPOWER_FULFILLMENT_CHANNEL("empower_fulfillment_channel"),
    
    POST_SORT_EVENT_CHANNEL("post_sort_event_channel"),
    
    FILE_CHANNEL("file_channel"),
    
    EMAIL_CHANNEL("email_channel"),
    
    DOCUMENTRESPONSE_CHANNEL("documentresponse_channel"),
    
    AZURE_BLOB_CHANNEL("azure_blob_channel"),
    
    AWS_S3_CHANNEL("aws_s3_channel"),
    
    GCP_CS_OUT_CHANNEL("gcp_cs_out_channel"),
    
    GENERIC("generic"),
    
    GENERIC_CHANNEL("generic_channel"),
    
    UNKNOWN("unknown");

    private String value;

    SubTypesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SubTypesEnum fromValue(String value) {
      for (SubTypesEnum b : SubTypesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SubTypesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SubTypesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SubTypesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SubTypesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SubTypesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SUB_TYPES = "subTypes";
  @SerializedName(SERIALIZED_NAME_SUB_TYPES)
  private List<SubTypesEnum> subTypes;

  public NodeFilter() {
  }

  public NodeFilter ids(List<UUID> ids) {
    this.ids = ids;
    return this;
  }

  public NodeFilter addIdsItem(UUID idsItem) {
    if (this.ids == null) {
      this.ids = new ArrayList<>();
    }
    this.ids.add(idsItem);
    return this;
  }

   /**
   * Get ids
   * @return ids
  **/
  @javax.annotation.Nullable
  public List<UUID> getIds() {
    return ids;
  }

  public void setIds(List<UUID> ids) {
    this.ids = ids;
  }


  public NodeFilter types(List<TypesEnum> types) {
    this.types = types;
    return this;
  }

  public NodeFilter addTypesItem(TypesEnum typesItem) {
    if (this.types == null) {
      this.types = new ArrayList<>();
    }
    this.types.add(typesItem);
    return this;
  }

   /**
   * Get types
   * @return types
  **/
  @javax.annotation.Nullable
  public List<TypesEnum> getTypes() {
    return types;
  }

  public void setTypes(List<TypesEnum> types) {
    this.types = types;
  }


  public NodeFilter excludedTypes(List<ExcludedTypesEnum> excludedTypes) {
    this.excludedTypes = excludedTypes;
    return this;
  }

  public NodeFilter addExcludedTypesItem(ExcludedTypesEnum excludedTypesItem) {
    if (this.excludedTypes == null) {
      this.excludedTypes = new ArrayList<>();
    }
    this.excludedTypes.add(excludedTypesItem);
    return this;
  }

   /**
   * Get excludedTypes
   * @return excludedTypes
  **/
  @javax.annotation.Nullable
  public List<ExcludedTypesEnum> getExcludedTypes() {
    return excludedTypes;
  }

  public void setExcludedTypes(List<ExcludedTypesEnum> excludedTypes) {
    this.excludedTypes = excludedTypes;
  }


  public NodeFilter subtypes(List<SubtypesEnum> subtypes) {
    this.subtypes = subtypes;
    return this;
  }

  public NodeFilter addSubtypesItem(SubtypesEnum subtypesItem) {
    if (this.subtypes == null) {
      this.subtypes = new ArrayList<>();
    }
    this.subtypes.add(subtypesItem);
    return this;
  }

   /**
   * Get subtypes
   * @return subtypes
  **/
  @javax.annotation.Nullable
  public List<SubtypesEnum> getSubtypes() {
    return subtypes;
  }

  public void setSubtypes(List<SubtypesEnum> subtypes) {
    this.subtypes = subtypes;
  }


  public NodeFilter excludedSubtypes(List<ExcludedSubtypesEnum> excludedSubtypes) {
    this.excludedSubtypes = excludedSubtypes;
    return this;
  }

  public NodeFilter addExcludedSubtypesItem(ExcludedSubtypesEnum excludedSubtypesItem) {
    if (this.excludedSubtypes == null) {
      this.excludedSubtypes = new ArrayList<>();
    }
    this.excludedSubtypes.add(excludedSubtypesItem);
    return this;
  }

   /**
   * Get excludedSubtypes
   * @return excludedSubtypes
  **/
  @javax.annotation.Nullable
  public List<ExcludedSubtypesEnum> getExcludedSubtypes() {
    return excludedSubtypes;
  }

  public void setExcludedSubtypes(List<ExcludedSubtypesEnum> excludedSubtypes) {
    this.excludedSubtypes = excludedSubtypes;
  }


  public NodeFilter name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public NodeFilter caseSensitive(Boolean caseSensitive) {
    this.caseSensitive = caseSensitive;
    return this;
  }

   /**
   * Get caseSensitive
   * @return caseSensitive
  **/
  @javax.annotation.Nullable
  public Boolean getCaseSensitive() {
    return caseSensitive;
  }

  public void setCaseSensitive(Boolean caseSensitive) {
    this.caseSensitive = caseSensitive;
  }


  public NodeFilter wholeWord(Boolean wholeWord) {
    this.wholeWord = wholeWord;
    return this;
  }

   /**
   * Get wholeWord
   * @return wholeWord
  **/
  @javax.annotation.Nullable
  public Boolean getWholeWord() {
    return wholeWord;
  }

  public void setWholeWord(Boolean wholeWord) {
    this.wholeWord = wholeWord;
  }


  public NodeFilter subTypes(List<SubTypesEnum> subTypes) {
    this.subTypes = subTypes;
    return this;
  }

  public NodeFilter addSubTypesItem(SubTypesEnum subTypesItem) {
    if (this.subTypes == null) {
      this.subTypes = new ArrayList<>();
    }
    this.subTypes.add(subTypesItem);
    return this;
  }

   /**
   * Get subTypes
   * @return subTypes
  **/
  @javax.annotation.Nullable
  public List<SubTypesEnum> getSubTypes() {
    return subTypes;
  }

  public void setSubTypes(List<SubTypesEnum> subTypes) {
    this.subTypes = subTypes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NodeFilter nodeFilter = (NodeFilter) o;
    return Objects.equals(this.ids, nodeFilter.ids) &&
        Objects.equals(this.types, nodeFilter.types) &&
        Objects.equals(this.excludedTypes, nodeFilter.excludedTypes) &&
        Objects.equals(this.subtypes, nodeFilter.subtypes) &&
        Objects.equals(this.excludedSubtypes, nodeFilter.excludedSubtypes) &&
        Objects.equals(this.name, nodeFilter.name) &&
        Objects.equals(this.caseSensitive, nodeFilter.caseSensitive) &&
        Objects.equals(this.wholeWord, nodeFilter.wholeWord) &&
        Objects.equals(this.subTypes, nodeFilter.subTypes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ids, types, excludedTypes, subtypes, excludedSubtypes, name, caseSensitive, wholeWord, subTypes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NodeFilter {\n");
    sb.append("    ids: ").append(toIndentedString(ids)).append("\n");
    sb.append("    types: ").append(toIndentedString(types)).append("\n");
    sb.append("    excludedTypes: ").append(toIndentedString(excludedTypes)).append("\n");
    sb.append("    subtypes: ").append(toIndentedString(subtypes)).append("\n");
    sb.append("    excludedSubtypes: ").append(toIndentedString(excludedSubtypes)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    caseSensitive: ").append(toIndentedString(caseSensitive)).append("\n");
    sb.append("    wholeWord: ").append(toIndentedString(wholeWord)).append("\n");
    sb.append("    subTypes: ").append(toIndentedString(subTypes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ids");
    openapiFields.add("types");
    openapiFields.add("excludedTypes");
    openapiFields.add("subtypes");
    openapiFields.add("excludedSubtypes");
    openapiFields.add("name");
    openapiFields.add("caseSensitive");
    openapiFields.add("wholeWord");
    openapiFields.add("subTypes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to NodeFilter
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NodeFilter.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NodeFilter is not found in the empty JSON string", NodeFilter.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NodeFilter.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NodeFilter` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("ids") != null && !jsonObj.get("ids").isJsonNull() && !jsonObj.get("ids").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ids` to be an array in the JSON string but got `%s`", jsonObj.get("ids").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("types") != null && !jsonObj.get("types").isJsonNull() && !jsonObj.get("types").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `types` to be an array in the JSON string but got `%s`", jsonObj.get("types").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedTypes") != null && !jsonObj.get("excludedTypes").isJsonNull() && !jsonObj.get("excludedTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedTypes` to be an array in the JSON string but got `%s`", jsonObj.get("excludedTypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("subtypes") != null && !jsonObj.get("subtypes").isJsonNull() && !jsonObj.get("subtypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subtypes` to be an array in the JSON string but got `%s`", jsonObj.get("subtypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedSubtypes") != null && !jsonObj.get("excludedSubtypes").isJsonNull() && !jsonObj.get("excludedSubtypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedSubtypes` to be an array in the JSON string but got `%s`", jsonObj.get("excludedSubtypes").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("subTypes") != null && !jsonObj.get("subTypes").isJsonNull() && !jsonObj.get("subTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subTypes` to be an array in the JSON string but got `%s`", jsonObj.get("subTypes").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NodeFilter.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NodeFilter' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NodeFilter> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NodeFilter.class));

       return (TypeAdapter<T>) new TypeAdapter<NodeFilter>() {
           @Override
           public void write(JsonWriter out, NodeFilter value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NodeFilter read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of NodeFilter given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of NodeFilter
  * @throws IOException if the JSON string is invalid with respect to NodeFilter
  */
  public static NodeFilter fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NodeFilter.class);
  }

 /**
  * Convert an instance of NodeFilter to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

