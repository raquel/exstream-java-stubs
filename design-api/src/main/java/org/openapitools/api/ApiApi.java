/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.2.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import org.openapitools.model.CreateThemeRequest;
import org.openapitools.model.DataResponseImportResponse;
import org.openapitools.model.DataResponseLinkDTO;
import org.openapitools.model.DataResponseResource;
import org.openapitools.model.DataResponseResourceVersion;
import org.openapitools.model.DataResponseTheme;
import org.springframework.format.annotation.DateTimeFormat;
import org.openapitools.model.Domain;
import org.openapitools.model.GenericResponse;
import org.openapitools.model.LinkDTO;
import org.openapitools.model.ListResponseImportHistory;
import org.openapitools.model.ListResponseLinkDTO;
import org.openapitools.model.ListResponseResourceHistory;
import org.openapitools.model.MultipleLinksBody;
import java.time.OffsetDateTime;
import org.openapitools.model.PageResponseLinkDTO;
import org.openapitools.model.PageResponseResourceVersion;
import org.openapitools.model.PostGetThemeWithOptionsPayload;
import org.openapitools.model.ResourceVersion;
import org.openapitools.model.Theme;
import java.util.UUID;
import org.openapitools.model.WorkflowRequestBody;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import jakarta.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2025-03-18T17:54:43.132703260Z[Europe/Lisbon]")
@Validated
@Tag(name = "links-controller", description = "Links Controller")
public interface ApiApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * POST /api/v1/links/{domain} : Create a resource link
     *
     * @param domain domain (required)
     * @param link link (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "createLinkUsingPOST",
        summary = "Create a resource link",
        tags = { "links-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseLinkDTO.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/links/{domain}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseLinkDTO> createLinkUsingPOST(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "link", description = "link", required = true) @Valid @RequestBody LinkDTO link
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/links/{domain}/multiple : Create multiple resource links
     *
     * @param domain domain (required)
     * @param body body (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "createLinksUsingPOST",
        summary = "Create multiple resource links",
        tags = { "links-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListResponseLinkDTO.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/links/{domain}/multiple",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<ListResponseLinkDTO> createLinksUsingPOST(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "body", description = "body", required = true) @Valid @RequestBody MultipleLinksBody body
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/resources/{domain}/content : Create resource from file
     *
     * @param domain domain (required)
     * @param name The name of the resource to create. (required)
     * @param type The type of resource to create. (required)
     * @param file The binary file to upload. (required)
     * @param subtype The subtype of resource to create. Appears in metadata. (optional)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "createResourceFromFileUsingPOST",
        summary = "Create resource from file",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/resources/{domain}/content",
        produces = { "*/*" },
        consumes = { "multipart/form-data" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> createResourceFromFileUsingPOST(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @NotNull @Parameter(name = "name", description = "The name of the resource to create.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "type", description = "The type of resource to create.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = true) String type,
        @Parameter(name = "file", description = "The binary file to upload.", required = true) @RequestPart(value = "file", required = true) MultipartFile file,
        @Parameter(name = "subtype", description = "The subtype of resource to create. Appears in metadata.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subtype", required = false) String subtype
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/resources/{domain} : Create a new resource
     *
     * @param domain domain (required)
     * @param body body (required)
     * @param charsetRegistered  (optional)
     * @param concrete  (optional)
     * @param contentMimeType contentMimeType (optional)
     * @param qualityValue  (optional)
     * @param subtype  (optional)
     * @param type  (optional)
     * @param wildcardSubtype  (optional)
     * @param wildcardType  (optional)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "createResourceUsingPOST",
        summary = "Create a new resource",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/resources/{domain}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> createResourceUsingPOST(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "body", description = "body", required = true) @Valid @RequestBody ResourceVersion body,
        @Parameter(name = "charset.registered", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "charset.registered", required = false) Boolean charsetRegistered,
        @Parameter(name = "concrete", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "concrete", required = false) Boolean concrete,
        @Parameter(name = "contentMimeType", description = "contentMimeType", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentMimeType", required = false) String contentMimeType,
        @Parameter(name = "qualityValue", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "qualityValue", required = false) Double qualityValue,
        @Parameter(name = "subtype", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subtype", required = false) String subtype,
        @Parameter(name = "type", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) String type,
        @Parameter(name = "wildcardSubtype", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "wildcardSubtype", required = false) Boolean wildcardSubtype,
        @Parameter(name = "wildcardType", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "wildcardType", required = false) Boolean wildcardType
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/themes/{domain} : Create a theme
     *
     * @param domain domain (required)
     * @param request request (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "createThemeUsingPOST",
        summary = "Create a theme",
        tags = { "theme-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/themes/{domain}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> createThemeUsingPOST(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "request", description = "request", required = true) @Valid @RequestBody CreateThemeRequest request
    ) {
        getRequest().ifPresent(request1 -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request1.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request1, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/links/{domain} : Delete a resource link
     *
     * @param domain domain (required)
     * @param link link (required)
     * @return OK (status code 200)
     *         or No Content (status code 204)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     */
    @Operation(
        operationId = "deleteLinkUsingDELETE",
        summary = "Delete a resource link",
        tags = { "links-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "204", description = "No Content"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/links/{domain}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> deleteLinkUsingDELETE(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "link", description = "link", required = true) @Valid @RequestBody LinkDTO link
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/links/{domain}/multiple : Delete multiple resource links
     *
     * @param domain domain (required)
     * @param body body (required)
     * @return OK (status code 200)
     *         or No Content (status code 204)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     */
    @Operation(
        operationId = "deleteLinksUsingDELETE",
        summary = "Delete multiple resource links",
        tags = { "links-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "204", description = "No Content"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/links/{domain}/multiple",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> deleteLinksUsingDELETE(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "body", description = "body", required = true) @Valid @RequestBody MultipleLinksBody body
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/resources/{domain}/{id} : Delete a resource
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param version Valid values are LATEST, ALL, or an actual version number. If not specified, will use LATEST. (optional)
     * @return OK (status code 200)
     *         or No Content (status code 204)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     */
    @Operation(
        operationId = "deleteResourceUsingDELETE",
        summary = "Delete a resource",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "204", description = "No Content"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/resources/{domain}/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> deleteResourceUsingDELETE(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "version", description = "Valid values are LATEST, ALL, or an actual version number. If not specified, will use LATEST.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) String version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id}/demote : Disassociate (demote) resource from a domain
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param toDomain toDomain (required)
     * @param version version (optional, default to -1)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "demoteUsingPUT",
        summary = "Disassociate (demote) resource from a domain",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}/demote",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> demoteUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "toDomain", description = "toDomain", required = true) @Valid @RequestBody Domain toDomain,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false, defaultValue = "-1") Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/export/{domain}/{rootId} : Export a resource and its references into a ZIP file
     *
     * @param domain domain (required)
     * @param rootId rootId (required)
     * @param versions versions (optional, default to LATEST_APPROVED)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "exportResourcesFromRootInDomainUsingGET",
        summary = "Export a resource and its references into a ZIP file",
        tags = { "export-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/export/{domain}/{rootId}"
    )
    
    default ResponseEntity<Void> exportResourcesFromRootInDomainUsingGET(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "rootId", description = "rootId", required = true, in = ParameterIn.PATH) @PathVariable("rootId") UUID rootId,
        @Parameter(name = "versions", description = "versions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "versions", required = false, defaultValue = "LATEST_APPROVED") String versions
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/resources/{domain}/{id}/content : Fetch resource content
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param state state (optional)
     * @param version version (optional)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getContentUsingGET",
        summary = "Fetch resource content",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = Object.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/resources/{domain}/{id}/content",
        produces = { "*/*" }
    )
    
    default ResponseEntity<Object> getContentUsingGET(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "state", description = "state", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) String state,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/import/logs : Fetch import history
     *
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getImportHistoryUsingGET",
        summary = "Fetch import history",
        tags = { "import-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListResponseImportHistory.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/import/logs",
        produces = { "*/*" }
    )
    
    default ResponseEntity<ListResponseImportHistory> getImportHistoryUsingGET(
        
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/links/{domain} : Fetch links to/from a resource
     *
     * @param domain domain (required)
     * @param count For pagination, the number of entities per page (optional)
     * @param effectiveDate  (optional)
     * @param filter A simple filter that can be used in place of the complex filters. If the query asks for the latest version (which is the default), this filter&#39;s domains, types, states, and override ids are applied when determining the latest version. All other attributes of this filter are applied when building the link tree. The filter value is a semicolon delimited list of key value pairs. For example:  name:Example;states:DRAFT,APPROVED;searchString:*ample List values separate possible values with commas. Keys include: | filter name           | Filter value description                                                                        | |-----------------------|-------------------------------------------------------------------------------------------------| | description           | Match resources with this description.                                                          | | excludedTypes         | Match resources whose types do not appear in this comma-separated list.                         | | variableIsArray       | Matches resources against this value.                                                           | | variableType          | Match resources whose variableType is one of these specified.                                   | | ids                   | Match resources with ids in this comma-separated list.                                          | | excludedIds           | Match resources with ids that are NOT in this comma-separated list.                             | | parentId              | Exclude this resource and others directly linked to it. Only usable in the resources API.       | | parentVersion         | For use with parentId. Must use both.                                                           | | name                  | Match resources with this name.                                                                 | | overrideIds           | When matching by states, do not apply the states filter to resources with ids in this list.     | | overrideStates        | When matching by states, apply this states filter to resources with ids in the overrideIds list.| | resourcePackId        | Match resources with this resource pack id.                                                     | | searchString          | Match resources with names or descriptions matching this string. Use a &amp;ast; as a wildcard.     | | caseSensitive         | Specify if searches (name, description, searchString) are case sensitive or not.                | | wholeWord             | Specify if searches (name, description, searchString) match whole word or not.                  | | createdBy             | Match resources created by this user.                                                           | | lastModifiedBy        | Match resources last modified by this user.                                                     | | createdDateStart      | Match resources created on or after this date. (yyyy-MM-dd format).                                   | | createdDateEnd        | Match resources created before this date. (yyyy-MM-dd format).                                  | | lastModifiedDateStart | Match resources last modified on or after this date. (yyyy-MM-dd format).                             | | lastModifiedDateEnd   | Match resources last modified before this date. (yyyy-MM-dd format).                            | | states                | Match resources with states in this list. States include: DRAFT,REVIEW,APPROVED,REJECTED      | | latestVersion         | Set to false to fetch all versions of resources matching the rest of this filter. Only usable in the resources API.| | types                 | Match resources with types in this list. Types include: resourcepack, exstrapplication, exstrdocument, exstrpage, exstrcomponentobj, exstremail, exstrengine, exstrvariablebase, exstrpackage, exstrgraphicalmessage, exstrtextmessage, exstrparagraph, exstrparagraphsection, image, samplefile, exstrdatasource, exstrhtml5, versionedtemplate, documentdefinition, enginerundef, font, fontdefinition, exstrbarcode, exstrpapertype, exstrmessagetype, exstrmetadata, exstrcommunicationset, exstroutputqueue, exstroutput, exstrmigrationset, exstrmessaging         | | systemResource        | Match resources that are (or are not) system resources.                                         | | hasApprovedVersion    | Match resources where a previously approved version of the resources exist.                     | | hidden                | Match resources that are (or are not) hidden.                                                   | | includeVariants       | Set to true to include variants in the response. By default they are excluded unless standardVariantId is specified.| | standardVariantId     | Match resources that are variants of this specified one. Can not be used when includeVariants is explicitly false.  | | categories            | Match resources that are contain at least one of the categories from this list.                 | (optional)
     * @param linkDepth Optionally specify the maximum depth for a recursive traversal of a link tree. (optional, default to 1)
     * @param linkObjectId  (optional)
     * @param linkSubjectId  (optional)
     * @param linkSubjectVersion  (optional)
     * @param offset For pagination, fetch entities after this many (optional)
     * @param rfilter The query will use this value to filter resources after it has determined latest versions and traversed the link tree. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter&#39;s possible values. (optional)
     * @param sort Comma separated list of {asc|desc}_{field name} (optional)
     * @param tfilter The query will use this value to filter resources as the query traverses the link tree. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter&#39;s possible values. (optional)
     * @param useEffectiveDate  (optional)
     * @param vfilter The query will use this value to filter resources as the query determines latest versions. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter&#39;s possible values. (optional)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getLinksUsingGET",
        summary = "Fetch links to/from a resource",
        tags = { "links-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseLinkDTO.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/links/{domain}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseLinkDTO> getLinksUsingGET(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "count", description = "For pagination, the number of entities per page", in = ParameterIn.QUERY) @Valid @RequestParam(value = "count", required = false) Integer count,
        @Parameter(name = "effectiveDate", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "effectiveDate", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) OffsetDateTime effectiveDate,
        @Parameter(name = "filter", description = "A simple filter that can be used in place of the complex filters. If the query asks for the latest version (which is the default), this filter's domains, types, states, and override ids are applied when determining the latest version. All other attributes of this filter are applied when building the link tree. The filter value is a semicolon delimited list of key value pairs. For example:  name:Example;states:DRAFT,APPROVED;searchString:*ample List values separate possible values with commas. Keys include: | filter name           | Filter value description                                                                        | |-----------------------|-------------------------------------------------------------------------------------------------| | description           | Match resources with this description.                                                          | | excludedTypes         | Match resources whose types do not appear in this comma-separated list.                         | | variableIsArray       | Matches resources against this value.                                                           | | variableType          | Match resources whose variableType is one of these specified.                                   | | ids                   | Match resources with ids in this comma-separated list.                                          | | excludedIds           | Match resources with ids that are NOT in this comma-separated list.                             | | parentId              | Exclude this resource and others directly linked to it. Only usable in the resources API.       | | parentVersion         | For use with parentId. Must use both.                                                           | | name                  | Match resources with this name.                                                                 | | overrideIds           | When matching by states, do not apply the states filter to resources with ids in this list.     | | overrideStates        | When matching by states, apply this states filter to resources with ids in the overrideIds list.| | resourcePackId        | Match resources with this resource pack id.                                                     | | searchString          | Match resources with names or descriptions matching this string. Use a &ast; as a wildcard.     | | caseSensitive         | Specify if searches (name, description, searchString) are case sensitive or not.                | | wholeWord             | Specify if searches (name, description, searchString) match whole word or not.                  | | createdBy             | Match resources created by this user.                                                           | | lastModifiedBy        | Match resources last modified by this user.                                                     | | createdDateStart      | Match resources created on or after this date. (yyyy-MM-dd format).                                   | | createdDateEnd        | Match resources created before this date. (yyyy-MM-dd format).                                  | | lastModifiedDateStart | Match resources last modified on or after this date. (yyyy-MM-dd format).                             | | lastModifiedDateEnd   | Match resources last modified before this date. (yyyy-MM-dd format).                            | | states                | Match resources with states in this list. States include: DRAFT,REVIEW,APPROVED,REJECTED      | | latestVersion         | Set to false to fetch all versions of resources matching the rest of this filter. Only usable in the resources API.| | types                 | Match resources with types in this list. Types include: resourcepack, exstrapplication, exstrdocument, exstrpage, exstrcomponentobj, exstremail, exstrengine, exstrvariablebase, exstrpackage, exstrgraphicalmessage, exstrtextmessage, exstrparagraph, exstrparagraphsection, image, samplefile, exstrdatasource, exstrhtml5, versionedtemplate, documentdefinition, enginerundef, font, fontdefinition, exstrbarcode, exstrpapertype, exstrmessagetype, exstrmetadata, exstrcommunicationset, exstroutputqueue, exstroutput, exstrmigrationset, exstrmessaging         | | systemResource        | Match resources that are (or are not) system resources.                                         | | hasApprovedVersion    | Match resources where a previously approved version of the resources exist.                     | | hidden                | Match resources that are (or are not) hidden.                                                   | | includeVariants       | Set to true to include variants in the response. By default they are excluded unless standardVariantId is specified.| | standardVariantId     | Match resources that are variants of this specified one. Can not be used when includeVariants is explicitly false.  | | categories            | Match resources that are contain at least one of the categories from this list.                 |", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) String filter,
        @Parameter(name = "linkDepth", description = "Optionally specify the maximum depth for a recursive traversal of a link tree.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkDepth", required = false, defaultValue = "1") Integer linkDepth,
        @Parameter(name = "linkObjectId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkObjectId", required = false) UUID linkObjectId,
        @Parameter(name = "linkSubjectId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkSubjectId", required = false) UUID linkSubjectId,
        @Parameter(name = "linkSubjectVersion", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkSubjectVersion", required = false) Integer linkSubjectVersion,
        @Parameter(name = "offset", description = "For pagination, fetch entities after this many", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = false) Integer offset,
        @Parameter(name = "rfilter", description = "The query will use this value to filter resources after it has determined latest versions and traversed the link tree. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter's possible values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rfilter", required = false) String rfilter,
        @Parameter(name = "sort", description = "Comma separated list of {asc|desc}_{field name}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sort", required = false) String sort,
        @Parameter(name = "tfilter", description = "The query will use this value to filter resources as the query traverses the link tree. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter's possible values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tfilter", required = false) String tfilter,
        @Parameter(name = "useEffectiveDate", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useEffectiveDate", required = false) Boolean useEffectiveDate,
        @Parameter(name = "vfilter", description = "The query will use this value to filter resources as the query determines latest versions. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter's possible values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vfilter", required = false) String vfilter
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/resources/{domain}/{id}/content/{type} : Get additional resource content
     * Thumbnails for resources are included here as additional content.
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param type type (required)
     * @param state state (optional)
     * @param version version (optional)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getResourceContentUsingGET",
        summary = "Get additional resource content",
        description = "Thumbnails for resources are included here as additional content.",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/xml", schema = @Schema(implementation = Object.class)),
                @Content(mediaType = "image/png", schema = @Schema(implementation = Object.class)),
                @Content(mediaType = "text/xml", schema = @Schema(implementation = Object.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/resources/{domain}/{id}/content/{type}",
        produces = { "application/xml", "image/png", "text/xml" }
    )
    
    default ResponseEntity<Object> getResourceContentUsingGET(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "type", description = "type", required = true, in = ParameterIn.PATH) @PathVariable("type") String type,
        @Parameter(name = "state", description = "state", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) String state,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/resources/{domain}/history/{resourceId} : Fetch the history information of a resource
     *
     * @param domain domain (required)
     * @param resourceId resourceId (required)
     * @param fetchAcrossDomains fetchAcrossDomains (optional)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getResourceHistoryUsingGET",
        summary = "Fetch the history information of a resource",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ListResponseResourceHistory.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/resources/{domain}/history/{resourceId}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<ListResponseResourceHistory> getResourceHistoryUsingGET(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "resourceId", description = "resourceId", required = true, in = ParameterIn.PATH) @PathVariable("resourceId") UUID resourceId,
        @Parameter(name = "fetchAcrossDomains", description = "fetchAcrossDomains", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fetchAcrossDomains", required = false) Boolean fetchAcrossDomains
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/resources/{domain}/{id} : Fetch resource information
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param checkIfLatestVersion checkIfLatestVersion (optional, default to false)
     * @param expand expand (optional)
     * @param state state (optional)
     * @param version version (optional)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getResourceUsingGET",
        summary = "Fetch resource information",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/resources/{domain}/{id}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> getResourceUsingGET(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "checkIfLatestVersion", description = "checkIfLatestVersion", in = ParameterIn.QUERY) @Valid @RequestParam(value = "checkIfLatestVersion", required = false, defaultValue = "false") Boolean checkIfLatestVersion,
        @Parameter(name = "expand", description = "expand", in = ParameterIn.QUERY) @Valid @RequestParam(value = "expand", required = false) String expand,
        @Parameter(name = "state", description = "state", in = ParameterIn.QUERY) @Valid @RequestParam(value = "state", required = false) String state,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/links/{domain}/resources : Fetch resources that are linked to/from another resource
     *
     * @param domain domain (required)
     * @param count For pagination, the number of entities per page (optional)
     * @param effectiveDate  (optional)
     * @param filter A simple filter that can be used in place of the complex filters. If the query asks for the latest version (which is the default), this filter&#39;s domains, types, states, and override ids are applied when determining the latest version. All other attributes of this filter are applied when building the link tree. The filter value is a semicolon delimited list of key value pairs. For example:  name:Example;states:DRAFT,APPROVED;searchString:*ample List values separate possible values with commas. Keys include: | filter name           | Filter value description                                                                        | |-----------------------|-------------------------------------------------------------------------------------------------| | description           | Match resources with this description.                                                          | | excludedTypes         | Match resources whose types do not appear in this comma-separated list.                         | | variableIsArray       | Matches resources against this value.                                                           | | variableType          | Match resources whose variableType is one of these specified.                                   | | ids                   | Match resources with ids in this comma-separated list.                                          | | excludedIds           | Match resources with ids that are NOT in this comma-separated list.                             | | parentId              | Exclude this resource and others directly linked to it. Only usable in the resources API.       | | parentVersion         | For use with parentId. Must use both.                                                           | | name                  | Match resources with this name.                                                                 | | overrideIds           | When matching by states, do not apply the states filter to resources with ids in this list.     | | overrideStates        | When matching by states, apply this states filter to resources with ids in the overrideIds list.| | resourcePackId        | Match resources with this resource pack id.                                                     | | searchString          | Match resources with names or descriptions matching this string. Use a &amp;ast; as a wildcard.     | | caseSensitive         | Specify if searches (name, description, searchString) are case sensitive or not.                | | wholeWord             | Specify if searches (name, description, searchString) match whole word or not.                  | | createdBy             | Match resources created by this user.                                                           | | lastModifiedBy        | Match resources last modified by this user.                                                     | | createdDateStart      | Match resources created on or after this date. (yyyy-MM-dd format).                                   | | createdDateEnd        | Match resources created before this date. (yyyy-MM-dd format).                                  | | lastModifiedDateStart | Match resources last modified on or after this date. (yyyy-MM-dd format).                             | | lastModifiedDateEnd   | Match resources last modified before this date. (yyyy-MM-dd format).                            | | states                | Match resources with states in this list. States include: DRAFT,REVIEW,APPROVED,REJECTED      | | latestVersion         | Set to false to fetch all versions of resources matching the rest of this filter. Only usable in the resources API.| | types                 | Match resources with types in this list. Types include: resourcepack, exstrapplication, exstrdocument, exstrpage, exstrcomponentobj, exstremail, exstrengine, exstrvariablebase, exstrpackage, exstrgraphicalmessage, exstrtextmessage, exstrparagraph, exstrparagraphsection, image, samplefile, exstrdatasource, exstrhtml5, versionedtemplate, documentdefinition, enginerundef, font, fontdefinition, exstrbarcode, exstrpapertype, exstrmessagetype, exstrmetadata, exstrcommunicationset, exstroutputqueue, exstroutput, exstrmigrationset, exstrmessaging         | | systemResource        | Match resources that are (or are not) system resources.                                         | | hasApprovedVersion    | Match resources where a previously approved version of the resources exist.                     | | hidden                | Match resources that are (or are not) hidden.                                                   | | includeVariants       | Set to true to include variants in the response. By default they are excluded unless standardVariantId is specified.| | standardVariantId     | Match resources that are variants of this specified one. Can not be used when includeVariants is explicitly false.  | | categories            | Match resources that are contain at least one of the categories from this list.                 | (optional)
     * @param linkDepth Optionally specify the maximum depth for a recursive traversal of a link tree. (optional, default to 1)
     * @param linkObjectId  (optional)
     * @param linkSubjectId  (optional)
     * @param offset For pagination, fetch entities after this many (optional)
     * @param rfilter The query will use this value to filter resources after it has determined latest versions and traversed the link tree. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter&#39;s possible values. (optional)
     * @param sort Comma separated list of {asc|desc}_{field name} (optional)
     * @param tfilter The query will use this value to filter resources as the query traverses the link tree. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter&#39;s possible values. (optional)
     * @param useEffectiveDate  (optional)
     * @param vfilter The query will use this value to filter resources as the query determines latest versions. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter&#39;s possible values. (optional)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getResourcesUsingGET",
        summary = "Fetch resources that are linked to/from another resource",
        tags = { "links-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/links/{domain}/resources",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseResourceVersion> getResourcesUsingGET(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "count", description = "For pagination, the number of entities per page", in = ParameterIn.QUERY) @Valid @RequestParam(value = "count", required = false) Integer count,
        @Parameter(name = "effectiveDate", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "effectiveDate", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) OffsetDateTime effectiveDate,
        @Parameter(name = "filter", description = "A simple filter that can be used in place of the complex filters. If the query asks for the latest version (which is the default), this filter's domains, types, states, and override ids are applied when determining the latest version. All other attributes of this filter are applied when building the link tree. The filter value is a semicolon delimited list of key value pairs. For example:  name:Example;states:DRAFT,APPROVED;searchString:*ample List values separate possible values with commas. Keys include: | filter name           | Filter value description                                                                        | |-----------------------|-------------------------------------------------------------------------------------------------| | description           | Match resources with this description.                                                          | | excludedTypes         | Match resources whose types do not appear in this comma-separated list.                         | | variableIsArray       | Matches resources against this value.                                                           | | variableType          | Match resources whose variableType is one of these specified.                                   | | ids                   | Match resources with ids in this comma-separated list.                                          | | excludedIds           | Match resources with ids that are NOT in this comma-separated list.                             | | parentId              | Exclude this resource and others directly linked to it. Only usable in the resources API.       | | parentVersion         | For use with parentId. Must use both.                                                           | | name                  | Match resources with this name.                                                                 | | overrideIds           | When matching by states, do not apply the states filter to resources with ids in this list.     | | overrideStates        | When matching by states, apply this states filter to resources with ids in the overrideIds list.| | resourcePackId        | Match resources with this resource pack id.                                                     | | searchString          | Match resources with names or descriptions matching this string. Use a &ast; as a wildcard.     | | caseSensitive         | Specify if searches (name, description, searchString) are case sensitive or not.                | | wholeWord             | Specify if searches (name, description, searchString) match whole word or not.                  | | createdBy             | Match resources created by this user.                                                           | | lastModifiedBy        | Match resources last modified by this user.                                                     | | createdDateStart      | Match resources created on or after this date. (yyyy-MM-dd format).                                   | | createdDateEnd        | Match resources created before this date. (yyyy-MM-dd format).                                  | | lastModifiedDateStart | Match resources last modified on or after this date. (yyyy-MM-dd format).                             | | lastModifiedDateEnd   | Match resources last modified before this date. (yyyy-MM-dd format).                            | | states                | Match resources with states in this list. States include: DRAFT,REVIEW,APPROVED,REJECTED      | | latestVersion         | Set to false to fetch all versions of resources matching the rest of this filter. Only usable in the resources API.| | types                 | Match resources with types in this list. Types include: resourcepack, exstrapplication, exstrdocument, exstrpage, exstrcomponentobj, exstremail, exstrengine, exstrvariablebase, exstrpackage, exstrgraphicalmessage, exstrtextmessage, exstrparagraph, exstrparagraphsection, image, samplefile, exstrdatasource, exstrhtml5, versionedtemplate, documentdefinition, enginerundef, font, fontdefinition, exstrbarcode, exstrpapertype, exstrmessagetype, exstrmetadata, exstrcommunicationset, exstroutputqueue, exstroutput, exstrmigrationset, exstrmessaging         | | systemResource        | Match resources that are (or are not) system resources.                                         | | hasApprovedVersion    | Match resources where a previously approved version of the resources exist.                     | | hidden                | Match resources that are (or are not) hidden.                                                   | | includeVariants       | Set to true to include variants in the response. By default they are excluded unless standardVariantId is specified.| | standardVariantId     | Match resources that are variants of this specified one. Can not be used when includeVariants is explicitly false.  | | categories            | Match resources that are contain at least one of the categories from this list.                 |", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) String filter,
        @Parameter(name = "linkDepth", description = "Optionally specify the maximum depth for a recursive traversal of a link tree.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkDepth", required = false, defaultValue = "1") Integer linkDepth,
        @Parameter(name = "linkObjectId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkObjectId", required = false) UUID linkObjectId,
        @Parameter(name = "linkSubjectId", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "linkSubjectId", required = false) UUID linkSubjectId,
        @Parameter(name = "offset", description = "For pagination, fetch entities after this many", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = false) Integer offset,
        @Parameter(name = "rfilter", description = "The query will use this value to filter resources after it has determined latest versions and traversed the link tree. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter's possible values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "rfilter", required = false) String rfilter,
        @Parameter(name = "sort", description = "Comma separated list of {asc|desc}_{field name}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sort", required = false) String sort,
        @Parameter(name = "tfilter", description = "The query will use this value to filter resources as the query traverses the link tree. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter's possible values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tfilter", required = false) String tfilter,
        @Parameter(name = "useEffectiveDate", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useEffectiveDate", required = false) Boolean useEffectiveDate,
        @Parameter(name = "vfilter", description = "The query will use this value to filter resources as the query determines latest versions. This stepwise filter can be combined with the other stepwise filters. It cannot be combined with the simple filter parameter. See filter for details of this filter's possible values.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "vfilter", required = false) String vfilter
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/resources/{domain} : Fetch resources
     *
     * @param domain domain (required)
     * @param advancedFilter  (optional)
     * @param count For pagination, the number of entities per page (optional)
     * @param expand expand (optional)
     * @param fetchCategories fetchCategories (optional, default to false)
     * @param fetchDomains fetchDomains (optional, default to false)
     * @param fetchPermissions fetchPermissions (optional, default to false)
     * @param fetchVariants fetchVariants (optional, default to false)
     * @param filter The filter value is a semicolon delimited list of key value pairs. For example:  name:Example;states:DRAFT,APPROVED;searchString:*ample List values separate possible values with commas. Keys include: | filter name           | Filter value description                                                                        | |-----------------------|-------------------------------------------------------------------------------------------------| | description           | Match resources with this description.                                                          | | excludedTypes         | Match resources whose types do not appear in this comma-separated list.                         | | variableIsArray       | Matches resources against this value.                                                           | | variableType          | Match resources whose variableType is one of these specified.                                   | | ids                   | Match resources with ids in this comma-separated list.                                          | | excludedIds           | Match resources with ids that are NOT in this comma-separated list.                             | | parentId              | Exclude this resource and others directly linked to it. Only usable in the resources API.       | | parentVersion         | For use with parentId. Must use both.                                                           | | name                  | Match resources with this name.                                                                 | | overrideIds           | When matching by states, do not apply the states filter to resources with ids in this list.     | | overrideStates        | When matching by states, apply this states filter to resources with ids in the overrideIds list.| | resourcePackId        | Match resources with this resource pack id.                                                     | | searchString          | Match resources with names or descriptions matching this string. Use a &amp;ast; as a wildcard.     | | caseSensitive         | Specify if searches (name, description, searchString) are case sensitive or not.                | | wholeWord             | Specify if searches (name, description, searchString) match whole word or not.                  | | createdBy             | Match resources created by this user.                                                           | | lastModifiedBy        | Match resources last modified by this user.                                                     | | createdDateStart      | Match resources created on or after this date. (yyyy-MM-dd format).                                   | | createdDateEnd        | Match resources created before this date. (yyyy-MM-dd format).                                  | | lastModifiedDateStart | Match resources last modified on or after this date. (yyyy-MM-dd format).                             | | lastModifiedDateEnd   | Match resources last modified before this date. (yyyy-MM-dd format).                            | | states                | Match resources with states in this list. States include: DRAFT,REVIEW,APPROVED,REJECTED      | | latestVersion         | Set to false to fetch all versions of resources matching the rest of this filter. Only usable in the resources API.| | types                 | Match resources with types in this list. Types include: resourcepack, exstrapplication, exstrdocument, exstrpage, exstrcomponentobj, exstremail, exstrengine, exstrvariablebase, exstrpackage, exstrgraphicalmessage, exstrtextmessage, exstrparagraph, exstrparagraphsection, image, samplefile, exstrdatasource, exstrhtml5, versionedtemplate, documentdefinition, enginerundef, font, fontdefinition, exstrbarcode, exstrpapertype, exstrmessagetype, exstrmetadata, exstrcommunicationset, exstroutputqueue, exstroutput, exstrmigrationset, exstrmessaging         | | systemResource        | Match resources that are (or are not) system resources.                                         | | hasApprovedVersion    | Match resources where a previously approved version of the resources exist.                     | | hidden                | Match resources that are (or are not) hidden.                                                   | | includeVariants       | Set to true to include variants in the response. By default they are excluded unless standardVariantId is specified.| | standardVariantId     | Match resources that are variants of this specified one. Can not be used when includeVariants is explicitly false.  | | categories            | Match resources that are contain at least one of the categories from this list.                 | (optional)
     * @param offset For pagination, fetch entities after this many (optional)
     * @param sort Comma separated list of {asc|desc}_{field name} (optional)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getResourcesUsingGET1",
        summary = "Fetch resources",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = PageResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/resources/{domain}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<PageResponseResourceVersion> getResourcesUsingGET1(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "advancedFilter", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "advancedFilter", required = false) String advancedFilter,
        @Parameter(name = "count", description = "For pagination, the number of entities per page", in = ParameterIn.QUERY) @Valid @RequestParam(value = "count", required = false) Integer count,
        @Parameter(name = "expand", description = "expand", in = ParameterIn.QUERY) @Valid @RequestParam(value = "expand", required = false) String expand,
        @Parameter(name = "fetchCategories", description = "fetchCategories", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fetchCategories", required = false, defaultValue = "false") Boolean fetchCategories,
        @Parameter(name = "fetchDomains", description = "fetchDomains", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fetchDomains", required = false, defaultValue = "false") Boolean fetchDomains,
        @Parameter(name = "fetchPermissions", description = "fetchPermissions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fetchPermissions", required = false, defaultValue = "false") Boolean fetchPermissions,
        @Parameter(name = "fetchVariants", description = "fetchVariants", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fetchVariants", required = false, defaultValue = "false") Boolean fetchVariants,
        @Parameter(name = "filter", description = "The filter value is a semicolon delimited list of key value pairs. For example:  name:Example;states:DRAFT,APPROVED;searchString:*ample List values separate possible values with commas. Keys include: | filter name           | Filter value description                                                                        | |-----------------------|-------------------------------------------------------------------------------------------------| | description           | Match resources with this description.                                                          | | excludedTypes         | Match resources whose types do not appear in this comma-separated list.                         | | variableIsArray       | Matches resources against this value.                                                           | | variableType          | Match resources whose variableType is one of these specified.                                   | | ids                   | Match resources with ids in this comma-separated list.                                          | | excludedIds           | Match resources with ids that are NOT in this comma-separated list.                             | | parentId              | Exclude this resource and others directly linked to it. Only usable in the resources API.       | | parentVersion         | For use with parentId. Must use both.                                                           | | name                  | Match resources with this name.                                                                 | | overrideIds           | When matching by states, do not apply the states filter to resources with ids in this list.     | | overrideStates        | When matching by states, apply this states filter to resources with ids in the overrideIds list.| | resourcePackId        | Match resources with this resource pack id.                                                     | | searchString          | Match resources with names or descriptions matching this string. Use a &ast; as a wildcard.     | | caseSensitive         | Specify if searches (name, description, searchString) are case sensitive or not.                | | wholeWord             | Specify if searches (name, description, searchString) match whole word or not.                  | | createdBy             | Match resources created by this user.                                                           | | lastModifiedBy        | Match resources last modified by this user.                                                     | | createdDateStart      | Match resources created on or after this date. (yyyy-MM-dd format).                                   | | createdDateEnd        | Match resources created before this date. (yyyy-MM-dd format).                                  | | lastModifiedDateStart | Match resources last modified on or after this date. (yyyy-MM-dd format).                             | | lastModifiedDateEnd   | Match resources last modified before this date. (yyyy-MM-dd format).                            | | states                | Match resources with states in this list. States include: DRAFT,REVIEW,APPROVED,REJECTED      | | latestVersion         | Set to false to fetch all versions of resources matching the rest of this filter. Only usable in the resources API.| | types                 | Match resources with types in this list. Types include: resourcepack, exstrapplication, exstrdocument, exstrpage, exstrcomponentobj, exstremail, exstrengine, exstrvariablebase, exstrpackage, exstrgraphicalmessage, exstrtextmessage, exstrparagraph, exstrparagraphsection, image, samplefile, exstrdatasource, exstrhtml5, versionedtemplate, documentdefinition, enginerundef, font, fontdefinition, exstrbarcode, exstrpapertype, exstrmessagetype, exstrmetadata, exstrcommunicationset, exstroutputqueue, exstroutput, exstrmigrationset, exstrmessaging         | | systemResource        | Match resources that are (or are not) system resources.                                         | | hasApprovedVersion    | Match resources where a previously approved version of the resources exist.                     | | hidden                | Match resources that are (or are not) hidden.                                                   | | includeVariants       | Set to true to include variants in the response. By default they are excluded unless standardVariantId is specified.| | standardVariantId     | Match resources that are variants of this specified one. Can not be used when includeVariants is explicitly false.  | | categories            | Match resources that are contain at least one of the categories from this list.                 |", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) String filter,
        @Parameter(name = "offset", description = "For pagination, fetch entities after this many", in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = false) Integer offset,
        @Parameter(name = "sort", description = "Comma separated list of {asc|desc}_{field name}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sort", required = false) String sort
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /api/v1/themes/{domain}/{themeId} : Fetch theme
     *
     * @param domain domain (required)
     * @param themeId themeId (required)
     * @param version version (optional, default to -1)
     * @return OK (status code 200)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getThemeUsingGET",
        summary = "Fetch theme",
        tags = { "theme-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseTheme.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/themes/{domain}/{themeId}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseTheme> getThemeUsingGET(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "themeId", description = "themeId", required = true, in = ParameterIn.PATH) @PathVariable("themeId") UUID themeId,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false, defaultValue = "-1") Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/themes/{domain}/{themeId} : Fetch theme with options payload
     *
     * @param domain domain (required)
     * @param themeId themeId (required)
     * @param version version (optional, default to -1)
     * @param options options (optional)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "getThemeWithOptionsUsingPOST",
        summary = "Fetch theme with options payload",
        tags = { "theme-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseTheme.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/themes/{domain}/{themeId}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseTheme> getThemeWithOptionsUsingPOST(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "themeId", description = "themeId", required = true, in = ParameterIn.PATH) @PathVariable("themeId") UUID themeId,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false, defaultValue = "-1") Integer version,
        @Parameter(name = "options", description = "options") @Valid @RequestBody(required = false) PostGetThemeWithOptionsPayload options
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id}/hide : Hide resource
     *
     * @param domain domain (required)
     * @param id id (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "hideResourceUsingPUT",
        summary = "Hide resource",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResource.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}/hide",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseResource> hideResourceUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/import/{packagetype}/{domain} : Import a package that was previously exported
     *
     * @param domain domain (required)
     * @param packagetype packagetype (required)
     * @param commit Set to false to do a dry run (optional)
     * @param previousExportPackage The id of a previously uploaded export package. (optional)
     * @param exportPackage The zip of the export to import (optional)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "importPackageUsingPOST",
        summary = "Import a package that was previously exported",
        tags = { "import-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseImportResponse.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/import/{packagetype}/{domain}",
        produces = { "*/*" },
        consumes = { "multipart/form-data" }
    )
    
    default ResponseEntity<DataResponseImportResponse> importPackageUsingPOST(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "packagetype", description = "packagetype", required = true, in = ParameterIn.PATH) @PathVariable("packagetype") String packagetype,
        @Parameter(name = "commit", description = "Set to false to do a dry run", in = ParameterIn.QUERY) @Valid @RequestParam(value = "commit", required = false) String commit,
        @Parameter(name = "previousExportPackage", description = "The id of a previously uploaded export package.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "previousExportPackage", required = false) String previousExportPackage,
        @Parameter(name = "exportPackage", description = "The zip of the export to import") @RequestPart(value = "exportPackage", required = false) MultipartFile exportPackage
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /api/v1/resources/{domain}/{id}/lock : Lock resource
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param version version (optional)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "lockResourceUsingPOST",
        summary = "Lock resource",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/resources/{domain}/{id}/lock",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> lockResourceUsingPOST(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id}/promote : Associate (promote) resource to a domain
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param toDomain toDomain (required)
     * @param version version (optional, default to -1)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "promoteUsingPUT",
        summary = "Associate (promote) resource to a domain",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}/promote",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> promoteUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "toDomain", description = "toDomain", required = true) @Valid @RequestBody Domain toDomain,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false, defaultValue = "-1") Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id}/revert/{oldVersion} : Revert to an older resource version
     * Replaces the content of the current draft, or create a new draft with content of specified version. Copies links as well.
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param oldVersion oldVersion (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "revertToOldVersionUsingPUT",
        summary = "Revert to an older resource version",
        description = "Replaces the content of the current draft, or create a new draft with content of specified version. Copies links as well.",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}/revert/{oldVersion}",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> revertToOldVersionUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "oldVersion", description = "oldVersion", required = true, in = ParameterIn.PATH) @PathVariable("oldVersion") Integer oldVersion
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id}/show : Show/Unhide resource
     *
     * @param domain domain (required)
     * @param id id (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "showResourceUsingPUT",
        summary = "Show/Unhide resource",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResource.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}/show",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseResource> showResourceUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * DELETE /api/v1/resources/{domain}/{id}/lock : Unlock resource
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param force When set to true, this will break a lock held by another user if the current user is a tenant admin. (optional, default to false)
     * @param version version (optional)
     * @return OK (status code 200)
     *         or No Content (status code 204)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     */
    @Operation(
        operationId = "unlockResourceUsingDELETE",
        summary = "Unlock resource",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "204", description = "No Content"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/resources/{domain}/{id}/lock",
        produces = { "*/*" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> unlockResourceUsingDELETE(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "force", description = "When set to true, this will break a lock held by another user if the current user is a tenant admin.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "force", required = false, defaultValue = "false") Boolean force,
        @Parameter(name = "version", description = "version", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) Integer version
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id}/content/{type} : Update additional resource content
     * Thumbnails for resources are included here as additional content. Expects a form part in the request body with the name \&quot;file\&quot; and will use the contents of that file to update the specified resource.
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param type type (required)
     * @param file The binary file to upload. (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "updateContentOfTypeViaFile",
        summary = "Update additional resource content",
        description = "Thumbnails for resources are included here as additional content. Expects a form part in the request body with the name \"file\" and will use the contents of that file to update the specified resource.",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}/content/{type}",
        produces = { "*/*" },
        consumes = { "multipart/form-data" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> updateContentOfTypeViaFile(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "type", description = "type", required = true, in = ParameterIn.PATH) @PathVariable("type") String type,
        @Parameter(name = "file", description = "The binary file to upload.", required = true) @RequestPart(value = "file", required = true) MultipartFile file
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id}/content : Update resource content
     * Expects a form part in the request body with the name \&quot;file\&quot; and will use the contents of that file to update the specified resource.
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param file The binary file to upload. (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "updateContentViaFileUsingPUT",
        summary = "Update resource content",
        description = "Expects a form part in the request body with the name \"file\" and will use the contents of that file to update the specified resource.",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}/content",
        produces = { "*/*" },
        consumes = { "multipart/form-data" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> updateContentViaFileUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "file", description = "The binary file to upload.", required = true) @RequestPart(value = "file", required = true) MultipartFile file
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id} : Upate resource information
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param body body (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "updateResourceUsingPUT",
        summary = "Upate resource information",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> updateResourceUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "body", description = "body", required = true) @Valid @RequestBody Object body
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/resources/{domain}/{id}/state : Update the workflow state of a resource
     *
     * @param domain domain (required)
     * @param id id (required)
     * @param stateRequest Resource states can be DRAFT, REVIEW, APPROVED, or REJECTED. (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "updateStateUsingPUT",
        summary = "Update the workflow state of a resource",
        tags = { "resources-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = DataResponseResourceVersion.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/resources/{domain}/{id}/state",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<DataResponseResourceVersion> updateStateUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "id", description = "id", required = true, in = ParameterIn.PATH) @PathVariable("id") UUID id,
        @Parameter(name = "stateRequest", description = "Resource states can be DRAFT, REVIEW, APPROVED, or REJECTED.", required = true) @Valid @RequestBody WorkflowRequestBody stateRequest
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf(""))) {
                    String exampleString = "";
                    ApiUtil.setExampleResponse(request, "", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/themes/{domain}/{themeId}/template : Update a theme to be based on the latest approved version of its template
     *
     * @param domain domain (required)
     * @param themeId themeId (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "updateTemplateUsingPUT",
        summary = "Update a theme to be based on the latest approved version of its template",
        tags = { "theme-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/themes/{domain}/{themeId}/template",
        produces = { "*/*" }
    )
    
    default ResponseEntity<GenericResponse> updateTemplateUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "themeId", description = "themeId", required = true, in = ParameterIn.PATH) @PathVariable("themeId") UUID themeId
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * PUT /api/v1/themes/{domain}/{themeId} : Update theme
     *
     * @param domain domain (required)
     * @param themeId themeId (required)
     * @param theme theme (required)
     * @return OK (status code 200)
     *         or Created (status code 201)
     *         or Unauthorized (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     */
    @Operation(
        operationId = "updateThemeUsingPUT",
        summary = "Update theme",
        tags = { "theme-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = GenericResponse.class))
            }),
            @ApiResponse(responseCode = "201", description = "Created"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "403", description = "Forbidden"),
            @ApiResponse(responseCode = "404", description = "Not Found")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/themes/{domain}/{themeId}",
        produces = { "*/*" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<GenericResponse> updateThemeUsingPUT(
        @Parameter(name = "domain", description = "domain", required = true, in = ParameterIn.PATH) @PathVariable("domain") String domain,
        @Parameter(name = "themeId", description = "themeId", required = true, in = ParameterIn.PATH) @PathVariable("themeId") UUID themeId,
        @Parameter(name = "theme", description = "theme", required = true) @Valid @RequestBody Theme theme
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("*/*"))) {
                    String exampleString = "{ \"status\" : \"status\" }";
                    ApiUtil.setExampleResponse(request, "*/*", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
